{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "db498d4f-b23c-4ff0-8fe4-f307f6c1bb8f",
   "metadata": {
    "jupyter": {
     "source_hidden": true
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Constants\n",
    "epsilon_0 = 8.854e-12  # Vacuum permittivity\n",
    "R = 0.5  # Radius of disk (m)\n",
    "sigma = 1e-3  # Surface charge density (C/m^2)\n",
    "z0 = 1.0  # Observation height (m)\n",
    "\n",
    "# Compute the electric field at each (x, y, z)\n",
    "def efield_disk(x, y, z, R, sigma):\n",
    "    r = np.sqrt(x**2 + y**2)  # Radial distance from the z-axis\n",
    "    \n",
    "    # Compute E_z component\n",
    "    E_z = (sigma / (2 * epsilon_0)) * (1 - z / np.sqrt(R**2 + z**2))\n",
    "\n",
    "    # Compute the radial E_r component\n",
    "    if r == 0:\n",
    "        return np.array([0, 0, E_z])  # No radial component at r=0\n",
    "\n",
    "    E_r = (sigma / (2 * epsilon_0)) * (R**2 / (z * np.sqrt(R**2 + z**2)))\n",
    "\n",
    "    # Convert radial component into Cartesian components\n",
    "    E_x = E_r * (x / r)\n",
    "    E_y = E_r * (y / r)\n",
    "\n",
    "    return np.array([E_x, E_y, E_z])\n",
    "\n",
    "# Grid for visualization\n",
    "x_vals = np.linspace(-2.0, 2.0, 20)\n",
    "y_vals = np.linspace(-2.0, 2.0, 20)\n",
    "X, Y = np.meshgrid(x_vals, y_vals)\n",
    "\n",
    "Ex_vals = np.zeros_like(X)\n",
    "Ey_vals = np.zeros_like(Y)\n",
    "Ez_vals = np.zeros_like(X)\n",
    "\n",
    "# Compute E-field at each grid point\n",
    "for i in range(X.shape[0]):\n",
    "    for j in range(X.shape[1]):\n",
    "        E = efield_disk(X[i, j], Y[i, j], z0, R, sigma)\n",
    "        Ex_vals[i, j], Ey_vals[i, j], Ez_vals[i, j] = E\n",
    "\n",
    "# Plot the field without opacity scaling\n",
    "plt.figure(figsize=(6, 6))\n",
    "quiver = plt.quiver(X, Y, Ex_vals, Ey_vals, color='b', scale=1e9)  # Adjusted scale\n",
    "plt.xlabel(\"x (m)\")\n",
    "plt.ylabel(\"y (m)\")\n",
    "plt.title(f\"Electric Field of a Charged Disk at z = {z0} m\")\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0d64c502-db11-4b7d-9507-c9b0160780a3",
   "metadata": {},
   "source": [
    "## Point Charge Ring Estimation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "46d96097-8d41-432f-a489-4b13cac5f739",
   "metadata": {
    "jupyter": {
     "source_hidden": true
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Constants\n",
    "epsilon_0 = 8.854e-12  # Vacuum permittivity\n",
    "R = 1.0  # Radius of ring (m)\n",
    "Q = 1e-6  # Total charge (C)\n",
    "z0 = 3.0  # Observation height (m)\n",
    "q = Q / 4  # Each point charge carries Q/4\n",
    "\n",
    "# Observation point (on the z-axis)\n",
    "obs_point = np.array([0, 0, z0])\n",
    "\n",
    "# Define four point charges on the ring (at 0, 90, 180, 270 degrees)\n",
    "angles = np.radians([0, 90, 180, 270])\n",
    "charge_points = np.array([[R * np.cos(theta), R * np.sin(theta), 0] for theta in angles])\n",
    "\n",
    "# Compute the field contribution from each charge\n",
    "E_total = np.array([0.0, 0.0, 0.0])\n",
    "\n",
    "for point in charge_points:\n",
    "    r_vec = obs_point - point  # Vector from charge to observation point\n",
    "    r_mag = np.linalg.norm(r_vec)  # Magnitude of r vector\n",
    "    dE_mag = (1 / (4 * np.pi * epsilon_0)) * (q / r_mag**3)  # Coulomb's Law\n",
    "    dE_vec = dE_mag * r_vec  # Field contribution\n",
    "    E_total += dE_vec  # Sum up contributions\n",
    "\n",
    "# Round the E-field components to the nearest 10^-6\n",
    "E_total = np.round(E_total, 2)\n",
    "\n",
    "# Print results\n",
    "print(f\"Total Electric Field at z = {z0} m: E_x = {E_total[0]:.2f} V/m , E_y = {E_total[1]:.2f} V/m, E_z = {E_total[2]:.2f}V/m\")\n",
    "\n",
    "# Visualization\n",
    "fig = plt.figure(figsize=(6, 6))\n",
    "ax = fig.add_subplot(111)\n",
    "\n",
    "# Plot the ring\n",
    "circle = plt.Circle((0, 0), R, color='gray', fill=False, linestyle='dashed')\n",
    "ax.add_patch(circle)\n",
    "\n",
    "# Plot the four charge points\n",
    "plt.scatter(charge_points[:, 0], charge_points[:, 1], color='red', label=\"Point Charges\")\n",
    "\n",
    "# Plot the observation point\n",
    "plt.scatter(0, 0, color='blue', marker='x', s=100, label=\"Observation Point (on z-axis)\")\n",
    "\n",
    "# Formatting\n",
    "plt.xlabel(\"x (m)\")\n",
    "plt.ylabel(\"y (m)\")\n",
    "plt.axhline(0, color='black', linewidth=0.5)\n",
    "plt.axvline(0, color='black', linewidth=0.5)\n",
    "plt.legend()\n",
    "plt.title(\"Approximation of Ring by 4 Point Charges and E-field at z-axis\")\n",
    "plt.xlim(-1.5, 1.5)\n",
    "plt.ylim(-1.5, 1.5)\n",
    "plt.grid()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a0a124e1-eafe-496a-b1e2-b8ce30c3ec02",
   "metadata": {},
   "source": [
    "# Field from Single charge"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e51bc07d-d112-4be4-aa71-ae074b78beed",
   "metadata": {
    "jupyter": {
     "source_hidden": true
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def electric_field(charge, charge_position, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the electric field vector at a point due to a point charge.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    charge : float\n",
    "        The charge in Coulombs\n",
    "    charge_position : array-like\n",
    "        The position of the charge as [x, y, z] coordinates\n",
    "    field_point : array-like\n",
    "        The position where we want to calculate the field as [x, y, z] coordinates\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    E_field : numpy.ndarray\n",
    "        The electric field vector [Ex, Ey, Ez] in N/C (Newtons per Coulomb)\n",
    "    \"\"\"\n",
    "    # Convert inputs to numpy arrays\n",
    "    charge_position = np.array(charge_position)\n",
    "    field_point = np.array(field_point)\n",
    "    \n",
    "    # Calculate displacement vector from charge to field point\n",
    "    r_vector = field_point - charge_position\n",
    "    \n",
    "    # Calculate distance\n",
    "    r = np.linalg.norm(r_vector)\n",
    "    \n",
    "    # Check for singularity (field point at charge position)\n",
    "    if r < 1e-10:\n",
    "        print(\"Warning: Field point too close to charge. Returning zero field.\")\n",
    "        return np.zeros(3)\n",
    "    \n",
    "    # Calculate unit vector\n",
    "    r_hat = r_vector / r\n",
    "    \n",
    "    # Calculate electric field magnitude\n",
    "    # E = kq/r², where k is Coulomb's constant\n",
    "    k = 8.9875e9  # Coulomb's constant (N·m²/C²)\n",
    "    E_magnitude = k * charge / (r**2)\n",
    "    \n",
    "    # Calculate electric field vector\n",
    "    E_field = E_magnitude * r_hat\n",
    "    \n",
    "    return E_field\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Example usage\n",
    "    charge = 1e-9  # 1 nC (nanocoulomb)\n",
    "    charge_position = [0, 0, 0]  # At the origin\n",
    "    \n",
    "# Calculate field at a specific point\n",
    "field_point = [1, 1, 1]  # 1 meter in each direction\n",
    "E = electric_field(charge, charge_position, field_point)\n",
    "print(f\"Electric field at {field_point} is [{E[0]:.3e}, {E[1]:.3e}, {E[2]:.3e}] N/C\")\n",
    "print(f\"Field magnitude: {np.linalg.norm(E):.4e} N/C\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "782e771a-55c3-4d60-aabe-37a5fe9b86aa",
   "metadata": {},
   "source": [
    "# Field from multiple charges"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "125e28e9-a1bb-48a6-8a41-827380d9c82b",
   "metadata": {
    "jupyter": {
     "source_hidden": true
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def electric_field(charge, charge_position, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the electric field vector at a point due to a point charge.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    charge : float\n",
    "        The charge in Coulombs\n",
    "    charge_position : array-like\n",
    "        The position of the charge as [x, y, z] coordinates\n",
    "    field_point : array-like\n",
    "        The position where we want to calculate the field as [x, y, z] coordinates\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    E_field : numpy.ndarray\n",
    "        The electric field vector [Ex, Ey, Ez] in N/C (Newtons per Coulomb)\n",
    "    \"\"\"\n",
    "    # Convert inputs to numpy arrays\n",
    "    charge_position = np.array(charge_position)\n",
    "    field_point = np.array(field_point)\n",
    "    \n",
    "    # Calculate displacement vector from charge to field point\n",
    "    r_vector = field_point - charge_position\n",
    "    \n",
    "    # Calculate distance\n",
    "    r = np.linalg.norm(r_vector)\n",
    "    \n",
    "    # Check for singularity (field point at charge position)\n",
    "    if r < 1e-10:\n",
    "        print(\"Warning: Field point too close to charge. Returning zero field.\")\n",
    "        return np.zeros(3)\n",
    "    \n",
    "    # Calculate unit vector\n",
    "    r_hat = r_vector / r\n",
    "    \n",
    "    # Calculate electric field magnitude\n",
    "    # E = kq/r², where k is Coulomb's constant\n",
    "    k = 8.9875e9  # Coulomb's constant (N·m²/C²)\n",
    "    E_magnitude = k * charge / (r**2)\n",
    "    \n",
    "    # Calculate electric field vector\n",
    "    E_field = E_magnitude * r_hat\n",
    "    \n",
    "    return E_field\n",
    "\n",
    "def electric_field_multiple_charges(charges, charge_positions, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the total electric field vector at a point due to multiple point charges.\n",
    "    Uses the principle of superposition.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    charges : list or numpy.ndarray\n",
    "        List of charge values in Coulombs\n",
    "    charge_positions : list of lists or numpy.ndarray\n",
    "        List of positions for each charge as [x, y, z] coordinates\n",
    "    field_point : list or numpy.ndarray\n",
    "        The position where we want to calculate the field as [x, y, z] coordinates\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    total_E_field : numpy.ndarray\n",
    "        The total electric field vector [Ex, Ey, Ez] in N/C (Newtons per Coulomb)\n",
    "    \"\"\"\n",
    "    # Initialize total field\n",
    "    total_E_field = np.zeros(3)\n",
    "    \n",
    "    # Sum the contributions from each charge\n",
    "    for i, (charge, position) in enumerate(zip(charges, charge_positions)):\n",
    "        E_field = electric_field(charge, position, field_point)\n",
    "        total_E_field += E_field\n",
    "        \n",
    "    return total_E_field\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Example usage with multiple charges\n",
    "    \n",
    "    # Define charges and their positions\n",
    "    charges = [1e-9, 1e-9, 1e-9, 1e-9,1e-9,1e-9,1e-9,1e-9]  # Charges in Coulombs\n",
    "    charge_positions = [\n",
    "        [0, -1, 0],     # First charge at y=-1\n",
    "        [1, 0, 0],     # Second charge at x=1 \n",
    "        [0, 1, 0],     # Third charge at y=1\n",
    "        [-1, 0, 0],     # Fourth Charge x=-1\n",
    "        [0.707,0.707,0], \n",
    "        [-0.707,-0.707,0],\n",
    "        [-0.707,0.707,0], \n",
    "        [0.707,-0.707,0]\n",
    "    ]\n",
    "\n",
    "    \n",
    "    # Calculate field at a specific point\n",
    "    field_point = [0, 0, 2]\n",
    "    \n",
    "    # Calculate electric field from each individual charge\n",
    "    print(\"Electric field from individual charges:\")\n",
    "    for i, (charge, position) in enumerate(zip(charges, charge_positions)):\n",
    "        E = electric_field(charge, position, field_point)\n",
    "        print(f\"Charge {i+1}: E = [{E[0]:.3}, {E[1]:.3}, {E[2]:.3}] N/C\")\n",
    "    \n",
    "    # Calculate the total electric field\n",
    "    total_E = electric_field_multiple_charges(charges, charge_positions, field_point)\n",
    "    print(\"\\nTotal electric field:\")\n",
    "    print(f\"E = [{total_E[0]:.3}, {total_E[1]:.3}, {total_E[2]:.3}] N/C\")\n",
    "    print(f\"Field magnitude: {np.linalg.norm(total_E):.4} N/C\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "703269a3-dcef-4d7e-9a8e-090a11e8257d",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true
   },
   "source": [
    "# Field from Uniformly-Charged Plate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "15a4b2db-5cd6-40db-a753-cdc0d083e174",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.colors import Normalize\n",
    "from matplotlib import cm\n",
    "\n",
    "# Reusing the existing functions from your code\n",
    "def electric_field(charge, charge_position, field_point):\n",
    "    # Convert inputs to numpy arrays\n",
    "    charge_position = np.array(charge_position)\n",
    "    field_point = np.array(field_point)\n",
    "    \n",
    "    # Calculate displacement vector from charge to field point\n",
    "    r_vector = field_point - charge_position\n",
    "    \n",
    "    # Calculate distance\n",
    "    r = np.linalg.norm(r_vector)\n",
    "    \n",
    "    # Check for singularity (field point at charge position)\n",
    "    if r < 1e-10:\n",
    "        return np.zeros(3)\n",
    "    \n",
    "    # Calculate unit vector\n",
    "    r_hat = r_vector / r\n",
    "    \n",
    "    # Calculate electric field magnitude\n",
    "    # E = kq/r², where k is Coulomb's constant\n",
    "    k = 8.9875e9  # Coulomb's constant (N·m²/C²)\n",
    "    E_magnitude = k * charge / (r**2)\n",
    "    \n",
    "    # Calculate electric field vector\n",
    "    E_field = E_magnitude * r_hat\n",
    "    \n",
    "    return E_field\n",
    "\n",
    "def electric_field_multiple_charges(charges, charge_positions, field_point):\n",
    "    # Initialize total field\n",
    "    total_E_field = np.zeros(3)\n",
    "    \n",
    "    # Sum the contributions from each charge\n",
    "    for i, (charge, position) in enumerate(zip(charges, charge_positions)):\n",
    "        E_field = electric_field(charge, position, field_point)\n",
    "        total_E_field += E_field\n",
    "        \n",
    "    return total_E_field\n",
    "\n",
    "def generate_charged_plate(width, height, nx, ny, charge_density, plate_orientation='xy', center_position=[0, 0, 0]):\n",
    "    \"\"\"\n",
    "    Generate a rectangular plate of point charges.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    width : float\n",
    "        Width of the plate in meters (first dimension)\n",
    "    height : float\n",
    "        Height of the plate in meters (second dimension)\n",
    "    nx : int\n",
    "        Number of charges along the width\n",
    "    ny : int\n",
    "        Number of charges along the height\n",
    "    charge_density : float\n",
    "        Surface charge density in C/m²\n",
    "    plate_orientation : str\n",
    "        Orientation of the plate ('xy', 'yz', or 'xz')\n",
    "    center_position : list\n",
    "        Center position of the plate [x, y, z]\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    charges : numpy.ndarray\n",
    "        Array of charge values for each point charge\n",
    "    positions : numpy.ndarray\n",
    "        Array of positions [x, y, z] for each point charge\n",
    "    \"\"\"\n",
    "    # Calculate the area represented by each point charge\n",
    "    dx = width / nx\n",
    "    dy = height / ny\n",
    "    area_per_charge = dx * dy\n",
    "    \n",
    "    # Calculate the charge value for each point\n",
    "    charge_value = charge_density * area_per_charge\n",
    "    \n",
    "    charges = []\n",
    "    positions = []\n",
    "    \n",
    "    center_position = np.array(center_position)\n",
    "    \n",
    "    # Create a grid of charges based on orientation\n",
    "    if plate_orientation == 'xy':  # Plate in xy-plane\n",
    "        for i in range(nx):\n",
    "            for j in range(ny):\n",
    "                # Calculate position (centered around specified position)\n",
    "                x = (i + 0.5) * dx - width/2 + center_position[0]\n",
    "                y = (j + 0.5) * dy - height/2 + center_position[1]\n",
    "                z = center_position[2]\n",
    "                \n",
    "                charges.append(charge_value)\n",
    "                positions.append([x, y, z])\n",
    "                \n",
    "    elif plate_orientation == 'yz':  # Plate in yz-plane\n",
    "        for i in range(nx):\n",
    "            for j in range(ny):\n",
    "                # Calculate position (centered around specified position)\n",
    "                y = (i + 0.5) * dx - width/2 + center_position[1]\n",
    "                z = (j + 0.5) * dy - height/2 + center_position[2]\n",
    "                x = center_position[0]\n",
    "                \n",
    "                charges.append(charge_value)\n",
    "                positions.append([x, y, z])\n",
    "                \n",
    "    elif plate_orientation == 'xz':  # Plate in xz-plane\n",
    "        for i in range(nx):\n",
    "            for j in range(ny):\n",
    "                # Calculate position (centered around specified position)\n",
    "                x = (i + 0.5) * dx - width/2 + center_position[0]\n",
    "                z = (j + 0.5) * dy - height/2 + center_position[2]\n",
    "                y = center_position[1]\n",
    "                \n",
    "                charges.append(charge_value)\n",
    "                positions.append([x, y, z])\n",
    "    \n",
    "    return np.array(charges), np.array(positions)\n",
    "\n",
    "def calculate_field_parallel_plane(charges, charge_positions, plate_orientation='xy', \n",
    "                                  observation_distance=0.5, plane_size=(1.0, 1.0), \n",
    "                                  num_points=(30, 30)):\n",
    "    \"\"\"\n",
    "    Calculate the electric field on a plane parallel to the charged plate.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    charges : numpy.ndarray\n",
    "        Array of charge values\n",
    "    charge_positions : numpy.ndarray\n",
    "        Array of charge positions\n",
    "    plate_orientation : str\n",
    "        Orientation of the plate ('xy', 'yz', or 'xz')\n",
    "    observation_distance : float\n",
    "        Distance from the plate to the observation plane\n",
    "    plane_size : tuple\n",
    "        Size of the observation plane (width, height)\n",
    "    num_points : tuple\n",
    "        Resolution of the grid (points_width, points_height)\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    grid1, grid2 : numpy.ndarray\n",
    "        Mesh grid coordinates for the observation plane\n",
    "    Ex, Ey, Ez : numpy.ndarray\n",
    "        Components of the electric field\n",
    "    E_mag : numpy.ndarray\n",
    "        Magnitude of the electric field\n",
    "    \"\"\"\n",
    "    # Determine the plate center position\n",
    "    plate_center = np.mean(charge_positions, axis=0)\n",
    "    \n",
    "    # Create mesh grid for the observation plane\n",
    "    if plate_orientation == 'xy':  # Plate in xy-plane, observation in xy-plane\n",
    "        # Observation plane is parallel to xy-plane at z = plate_center[2] + observation_distance\n",
    "        x = np.linspace(-plane_size[0]/2, plane_size[0]/2, num_points[0]) + plate_center[0]\n",
    "        y = np.linspace(-plane_size[1]/2, plane_size[1]/2, num_points[1]) + plate_center[1]\n",
    "        X, Y = np.meshgrid(x, y)\n",
    "        Z = np.full_like(X, plate_center[2] + observation_distance)\n",
    "        grid1, grid2 = X, Y  # First and second coordinates of the plane\n",
    "        \n",
    "    elif plate_orientation == 'yz':  # Plate in yz-plane, observation in yz-plane\n",
    "        # Observation plane is parallel to yz-plane at x = plate_center[0] + observation_distance\n",
    "        y = np.linspace(-plane_size[0]/2, plane_size[0]/2, num_points[0]) + plate_center[1]\n",
    "        z = np.linspace(-plane_size[1]/2, plane_size[1]/2, num_points[1]) + plate_center[2]\n",
    "        Y, Z = np.meshgrid(y, z)\n",
    "        X = np.full_like(Y, plate_center[0] + observation_distance)\n",
    "        grid1, grid2 = Y, Z  # First and second coordinates of the plane\n",
    "        \n",
    "    elif plate_orientation == 'xz':  # Plate in xz-plane, observation in xz-plane\n",
    "        # Observation plane is parallel to xz-plane at y = plate_center[1] + observation_distance\n",
    "        x = np.linspace(-plane_size[0]/2, plane_size[0]/2, num_points[0]) + plate_center[0]\n",
    "        z = np.linspace(-plane_size[1]/2, plane_size[1]/2, num_points[1]) + plate_center[2]\n",
    "        X, Z = np.meshgrid(x, z)\n",
    "        Y = np.full_like(X, plate_center[1] + observation_distance)\n",
    "        grid1, grid2 = X, Z  # First and second coordinates of the plane\n",
    "    \n",
    "    # Initialize field component arrays\n",
    "    Ex = np.zeros_like(grid1)\n",
    "    Ey = np.zeros_like(grid1)\n",
    "    Ez = np.zeros_like(grid1)\n",
    "    E_mag = np.zeros_like(grid1)\n",
    "    \n",
    "    # Calculate electric field at each point in the grid\n",
    "    for i in range(num_points[1]):\n",
    "        for j in range(num_points[0]):\n",
    "            field_point = [X[i, j], Y[i, j], Z[i, j]]\n",
    "                \n",
    "            E = electric_field_multiple_charges(charges, charge_positions, field_point)\n",
    "            \n",
    "            Ex[i, j] = E[0]\n",
    "            Ey[i, j] = E[1]\n",
    "            Ez[i, j] = E[2]\n",
    "            E_mag[i, j] = np.linalg.norm(E)\n",
    "    \n",
    "    return grid1, grid2, Ex, Ey, Ez, E_mag\n",
    "\n",
    "def plot_field_parallel_plane(grid1, grid2, Ex, Ey, Ez, E_mag, plate_orientation='xy', observation_distance=0.5):\n",
    "    \"\"\"\n",
    "    Plot the electric field on a plane parallel to the charged plate.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    grid1, grid2 : numpy.ndarray\n",
    "        Mesh grid coordinates for the observation plane\n",
    "    Ex, Ey, Ez : numpy.ndarray\n",
    "        Components of the electric field\n",
    "    E_mag : numpy.ndarray\n",
    "        Magnitude of the electric field\n",
    "    plate_orientation : str\n",
    "        Orientation of the plate ('xy', 'yz', or 'xz')\n",
    "    observation_distance : float\n",
    "        Distance from the plate to the observation plane\n",
    "    \"\"\"\n",
    "    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n",
    "    \n",
    "    # Get the components to plot based on orientation\n",
    "    if plate_orientation == 'xy':\n",
    "        # For xy-plane, show X and Y components, color by Z component\n",
    "        comp1, comp2 = Ex, Ey  # Vector components to plot (x, y)\n",
    "        perp_comp = Ez  # Perpendicular component (color)\n",
    "        ax1_label, ax2_label = 'X', 'Y'\n",
    "        perp_axis = 'Z'\n",
    "        \n",
    "    elif plate_orientation == 'yz':\n",
    "        # For yz-plane, show Y and Z components, color by X component\n",
    "        comp1, comp2 = Ey, Ez  # Vector components to plot (y, z)\n",
    "        perp_comp = Ex  # Perpendicular component (color)\n",
    "        ax1_label, ax2_label = 'Y', 'Z'\n",
    "        perp_axis = 'X'\n",
    "        \n",
    "    elif plate_orientation == 'xz':\n",
    "        # For xz-plane, show X and Z components, color by Y component\n",
    "        comp1, comp2 = Ex, Ez  # Vector components to plot (x, z)\n",
    "        perp_comp = Ey  # Perpendicular component (color)\n",
    "        ax1_label, ax2_label = 'X', 'Z'\n",
    "        perp_axis = 'Y'\n",
    "    \n",
    "    # Plot 1: Vector field of in-plane components\n",
    "    ax1.set_title(f'Electric Field Vector Plot ({perp_axis}={observation_distance}m)')\n",
    "    ax1.set_xlabel(f'{ax1_label} (m)')\n",
    "    ax1.set_ylabel(f'{ax2_label} (m)')\n",
    "    \n",
    "    # Plot a subset of vectors for clarity\n",
    "    skip = slice(None, None, 2)\n",
    "    quiv = ax1.quiver(grid1[skip, skip], grid2[skip, skip], comp1[skip, skip], comp2[skip, skip], \n",
    "               angles='xy', scale_units='xy', scale=90000, width=0.003)\n",
    "    \n",
    "    # Add a key/legend for the quiver plot\n",
    "    ax1.quiverkey(quiv, 0.9, 0.95, 50000, '50 kN/C', labelpos='E')\n",
    "    \n",
    "    ax1.grid(True)\n",
    "    ax1.set_aspect('equal')\n",
    "    \n",
    "    # Plot 2: Perpendicular component as color map\n",
    "    im = ax2.imshow(perp_comp, extent=[grid1.min(), grid1.max(), grid2.min(), grid2.max()], \n",
    "               origin='lower', cmap='viridis', aspect='auto')\n",
    "    \n",
    "    ax2.set_title(f'{perp_axis}-Component of Electric Field ({perp_axis}={observation_distance}m)')\n",
    "    ax2.set_xlabel(f'{ax1_label} (m)')\n",
    "    ax2.set_ylabel(f'{ax2_label} (m)')\n",
    "    \n",
    "    # Add colorbar\n",
    "    cbar = plt.colorbar(im, ax=ax2)\n",
    "    cbar.set_label(f'{perp_axis}-Component (N/C)')\n",
    "    \n",
    "    ax2.grid(True)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    return fig\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Configuration\n",
    "    plate_width = 2  # meters\n",
    "    plate_height = 2  # meters\n",
    "    nx = 30  # number of charges along width\n",
    "    ny = 30  # number of charges along height\n",
    "    charge_density = 1e-6  # C/m²\n",
    "    \n",
    "    # Set plate orientation - change this to 'xy', 'yz', or 'xz'\n",
    "    plate_orientation = 'yz'  # Plate in the yz-plane (x=0)\n",
    "    \n",
    "    # Generate the charged plate\n",
    "    charges, positions = generate_charged_plate(\n",
    "        plate_width, plate_height, nx, ny, \n",
    "        charge_density,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=[0, 0, 0]  # Plate centered at origin\n",
    "    )\n",
    "    \n",
    "    print(f\"Generated {len(charges)} charges for the plate\")\n",
    "    print(f\"Total charge: {np.sum(charges):.2e} C\")\n",
    "    \n",
    "    # Set the observation distance from the plate\n",
    "    observation_distance = 0.5  # meters\n",
    "    \n",
    "    # Calculate the field on the parallel plane\n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag = calculate_field_parallel_plane(\n",
    "        charges, positions,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance,\n",
    "        plane_size=(5.2, 5.2),  # Size of the observation plane (slightly larger than plate)\n",
    "        num_points=(40, 40)  # Resolution (higher = more detail but slower)\n",
    "    )\n",
    "    \n",
    "    # Plot the results\n",
    "    fig = plot_field_parallel_plane(\n",
    "        grid1, grid2, Ex, Ey, Ez, E_mag,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance\n",
    "    )\n",
    "    \n",
    "    # You can change the observation distance to see how the field changes\n",
    "    # For example:\n",
    "    \"\"\"\n",
    "    # Change observation distance\n",
    "    observation_distance = 0.5  # meters\n",
    "    \n",
    "    # Recalculate field\n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag = calculate_field_parallel_plane(\n",
    "        charges, positions,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance,\n",
    "        plane_size=(1.2, 1.2),\n",
    "        num_points=(40, 40)\n",
    "    )\n",
    "    \n",
    "    # Plot new results\n",
    "    fig = plot_field_parallel_plane(\n",
    "        grid1, grid2, Ex, Ey, Ez, E_mag,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance\n",
    "    )\n",
    "    \"\"\""
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aaf6dd78-5475-45c9-9617-5e79f38788b0",
   "metadata": {},
   "source": [
    "# Field from Non-Uniformly Charged Plate (Dipole)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cc89cab6-b4ff-495e-8ff3-66988ee628b6",
   "metadata": {
    "jupyter": {
     "source_hidden": true
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.colors import Normalize\n",
    "from matplotlib import cm\n",
    "\n",
    "# Reusing the existing functions from your code\n",
    "def electric_field(charge, charge_position, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the electric field at a point due to a single point charge.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    charge : float\n",
    "        Charge value in Coulombs\n",
    "    charge_position : array-like\n",
    "        Position of the charge [x, y, z] in meters\n",
    "    field_point : array-like\n",
    "        Position where the field is calculated [x, y, z] in meters\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    E_field : numpy.ndarray\n",
    "        Electric field vector [Ex, Ey, Ez] in N/C\n",
    "    \"\"\"\n",
    "    # Convert inputs to numpy arrays\n",
    "    charge_position = np.array(charge_position)\n",
    "    field_point = np.array(field_point)\n",
    "    \n",
    "    # Calculate displacement vector from charge to field point\n",
    "    r_vector = field_point - charge_position\n",
    "    \n",
    "    # Calculate distance\n",
    "    r = np.linalg.norm(r_vector)\n",
    "    \n",
    "    # Check for singularity (field point at charge position)\n",
    "    if r < 1e-10:\n",
    "        return np.zeros(3)\n",
    "    \n",
    "    # Calculate unit vector\n",
    "    r_hat = r_vector / r\n",
    "    \n",
    "    # Calculate electric field magnitude\n",
    "    # E = kq/r², where k is Coulomb's constant\n",
    "    k = 8.9875e9  # Coulomb's constant (N·m²/C²)\n",
    "    E_magnitude = k * charge / (r**2)\n",
    "    \n",
    "    # Calculate electric field vector\n",
    "    E_field = E_magnitude * r_hat\n",
    "    \n",
    "    return E_field\n",
    "\n",
    "def electric_field_multiple_charges(charges, charge_positions, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the total electric field at a point due to multiple charges.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    charges : array-like\n",
    "        Array of charge values in Coulombs\n",
    "    charge_positions : array-like\n",
    "        Array of charge positions, each [x, y, z] in meters\n",
    "    field_point : array-like\n",
    "        Position where the field is calculated [x, y, z] in meters\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    total_E_field : numpy.ndarray\n",
    "        Total electric field vector [Ex, Ey, Ez] in N/C\n",
    "    \"\"\"\n",
    "    # Initialize total field\n",
    "    total_E_field = np.zeros(3)\n",
    "    \n",
    "    # Sum the contributions from each charge\n",
    "    for i, (charge, position) in enumerate(zip(charges, charge_positions)):\n",
    "        E_field = electric_field(charge, position, field_point)\n",
    "        total_E_field += E_field\n",
    "        \n",
    "    return total_E_field\n",
    "\n",
    "def generate_charged_plate_non_uniform(width, height, nx, ny, charge_pattern='dipole', \n",
    "                                      plate_orientation='xy', center_position=[0, 0, 0], \n",
    "                                      pattern_params=None):\n",
    "    \"\"\"\n",
    "    Generate a rectangular plate with non-uniform charge distribution.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    width : float\n",
    "        Width of the plate in meters (first dimension)\n",
    "    height : float\n",
    "        Height of the plate in meters (second dimension)\n",
    "    nx : int\n",
    "        Number of charges along the width\n",
    "    ny : int\n",
    "        Number of charges along the height\n",
    "    charge_pattern : str\n",
    "        Type of charge distribution ('uniform', 'dipole', 'quadrupole', 'gaussian', 'custom')\n",
    "    plate_orientation : str\n",
    "        Orientation of the plate ('xy', 'yz', or 'xz')\n",
    "    center_position : list\n",
    "        Center position of the plate [x, y, z]\n",
    "    pattern_params : dict\n",
    "        Additional parameters for specific charge patterns:\n",
    "        - uniform: {'max_density': float}\n",
    "        - dipole: {'axis': 'x' or 'y', 'max_density': float}\n",
    "        - quadrupole: {'max_density': float}\n",
    "        - gaussian: {'sigma': float, 'amplitude': float}\n",
    "        - custom: {'function': callable that takes (x, y) and returns charge density}\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    charges : numpy.ndarray\n",
    "        Array of charge values for each point charge\n",
    "    positions : numpy.ndarray\n",
    "        Array of positions [x, y, z] for each point charge\n",
    "    \"\"\"\n",
    "    # Set default pattern parameters if not provided\n",
    "    if pattern_params is None:\n",
    "        if charge_pattern == 'uniform':\n",
    "            pattern_params = {'max_density': 1e-6}\n",
    "        elif charge_pattern == 'dipole':\n",
    "            pattern_params = {'axis': 'y', 'max_density': 1e-6}\n",
    "        elif charge_pattern == 'quadrupole':\n",
    "            pattern_params = {'max_density': 1e-6}\n",
    "        elif charge_pattern == 'gaussian':\n",
    "            pattern_params = {'sigma': 0.2, 'amplitude': 1e-6}\n",
    "        elif charge_pattern == 'custom':\n",
    "            # Default to a simple linear gradient along y-axis\n",
    "            pattern_params = {'function': lambda x, y: 1e-6 * y / (height/2)}\n",
    "    \n",
    "    # Calculate the area represented by each point charge\n",
    "    dx = width / nx\n",
    "    dy = height / ny\n",
    "    area_per_charge = dx * dy\n",
    "    \n",
    "    charges = []\n",
    "    positions = []\n",
    "    \n",
    "    center_position = np.array(center_position)\n",
    "    \n",
    "    # Create a grid of charges based on orientation\n",
    "    for i in range(nx):\n",
    "        for j in range(ny):\n",
    "            # Calculate position relative to center\n",
    "            rel_x = (i + 0.5) * dx - width/2\n",
    "            rel_y = (j + 0.5) * dy - height/2\n",
    "            \n",
    "            # Determine charge value based on pattern\n",
    "            if charge_pattern == 'uniform':\n",
    "                max_density = pattern_params.get('max_density', 1e-6)\n",
    "                # Uniform charge density (constant value)\n",
    "                charge_density = max_density\n",
    "            elif charge_pattern == 'dipole':\n",
    "                axis = pattern_params.get('axis', 'y')\n",
    "                max_density = pattern_params.get('max_density', 1e-6)\n",
    "                \n",
    "                if axis == 'x':\n",
    "                    # Dipole along x-axis\n",
    "                    charge_density = max_density * (rel_x / (width/2))\n",
    "                else:  # 'y'\n",
    "                    # Dipole along y-axis\n",
    "                    charge_density = max_density * (rel_y / (height/2))\n",
    "                    \n",
    "            elif charge_pattern == 'quadrupole':\n",
    "                max_density = pattern_params.get('max_density', 1e-6)\n",
    "                # Quadrupole pattern (alternating charges)\n",
    "                normalized_x = rel_x / (width/2)\n",
    "                normalized_y = rel_y / (height/2)\n",
    "                charge_density = max_density * normalized_x * normalized_y\n",
    "                \n",
    "            elif charge_pattern == 'gaussian':\n",
    "                sigma = pattern_params.get('sigma', 0.2)\n",
    "                amplitude = pattern_params.get('amplitude', 1e-6)\n",
    "                # Gaussian positive charge at center\n",
    "                r_squared = rel_x**2 + rel_y**2\n",
    "                charge_density = amplitude * np.exp(-r_squared / (2 * sigma**2))\n",
    "                \n",
    "            elif charge_pattern == 'custom' and 'function' in pattern_params:\n",
    "                # Use custom function to determine charge density\n",
    "                charge_density = pattern_params['function'](rel_x, rel_y)\n",
    "                \n",
    "            else:\n",
    "                raise ValueError(f\"Unknown charge pattern: {charge_pattern}\")\n",
    "                \n",
    "            # Calculate charge for this point\n",
    "            charge_value = charge_density * area_per_charge\n",
    "            \n",
    "            # Set position based on plate orientation\n",
    "            if plate_orientation == 'xy':  # Plate in xy-plane\n",
    "                x = rel_x + center_position[0]\n",
    "                y = rel_y + center_position[1]\n",
    "                z = center_position[2]\n",
    "                \n",
    "            elif plate_orientation == 'yz':  # Plate in yz-plane\n",
    "                y = rel_x + center_position[1]  # rel_x maps to y-axis\n",
    "                z = rel_y + center_position[2]  # rel_y maps to z-axis\n",
    "                x = center_position[0]\n",
    "                \n",
    "            elif plate_orientation == 'xz':  # Plate in xz-plane\n",
    "                x = rel_x + center_position[0]  # rel_x maps to x-axis\n",
    "                z = rel_y + center_position[2]  # rel_y maps to z-axis\n",
    "                y = center_position[1]\n",
    "                \n",
    "            charges.append(charge_value)\n",
    "            positions.append([x, y, z])\n",
    "    \n",
    "    return np.array(charges), np.array(positions)\n",
    "\n",
    "def visualize_charge_distribution(charges, positions, plate_orientation='xy'):\n",
    "    \"\"\"\n",
    "    Visualize the charge distribution on the plate.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    charges : numpy.ndarray\n",
    "        Array of charge values\n",
    "    positions : numpy.ndarray\n",
    "        Array of charge positions\n",
    "    plate_orientation : str\n",
    "        Orientation of the plate ('xy', 'yz', or 'xz')\n",
    "    \"\"\"\n",
    "    fig = plt.figure(figsize=(10, 8))\n",
    "    ax = fig.add_subplot(111)\n",
    "    \n",
    "    # Extract the 2D coordinates based on plate orientation\n",
    "    if plate_orientation == 'xy':\n",
    "        x_coords = positions[:, 0]\n",
    "        y_coords = positions[:, 1]\n",
    "        x_label, y_label = 'X', 'Y'\n",
    "    elif plate_orientation == 'yz':\n",
    "        x_coords = positions[:, 1]  # Y coordinate\n",
    "        y_coords = positions[:, 2]  # Z coordinate\n",
    "        x_label, y_label = 'Y', 'Z'\n",
    "    elif plate_orientation == 'xz':\n",
    "        x_coords = positions[:, 0]  # X coordinate\n",
    "        y_coords = positions[:, 2]  # Z coordinate\n",
    "        x_label, y_label = 'X', 'Z'\n",
    "    \n",
    "    # Create a scatter plot with charge as color\n",
    "    sc = ax.scatter(x_coords, y_coords, c=charges, cmap='RdBu_r', \n",
    "                   vmin=-np.max(np.abs(charges)), vmax=np.max(np.abs(charges)),\n",
    "                   s=50, alpha=0.8)\n",
    "    \n",
    "    # Add colorbar\n",
    "    cbar = plt.colorbar(sc, ax=ax)\n",
    "    cbar.set_label('Charge (C)')\n",
    "    \n",
    "    # Set labels\n",
    "    ax.set_xlabel(f'{x_label} (m)')\n",
    "    ax.set_ylabel(f'{y_label} (m)')\n",
    "    ax.set_title('Charge Distribution on Plate')\n",
    "    \n",
    "    ax.grid(True)\n",
    "    ax.set_aspect('equal')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    \n",
    "    return fig\n",
    "\n",
    "def calculate_field_parallel_plane(charges, charge_positions, plate_orientation='xy', \n",
    "                                  observation_distance=0.5, plane_size=(1.0, 1.0), \n",
    "                                  num_points=(30, 30)):\n",
    "    \"\"\"\n",
    "    Calculate the electric field on a plane parallel to the charged plate.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    charges : numpy.ndarray\n",
    "        Array of charge values\n",
    "    charge_positions : numpy.ndarray\n",
    "        Array of charge positions\n",
    "    plate_orientation : str\n",
    "        Orientation of the plate ('xy', 'yz', or 'xz')\n",
    "    observation_distance : float\n",
    "        Distance from the plate to the observation plane\n",
    "    plane_size : tuple\n",
    "        Size of the observation plane (width, height)\n",
    "    num_points : tuple\n",
    "        Resolution of the grid (points_width, points_height)\n",
    "        \n",
    "    Returns:\n",
    "    --------\n",
    "    grid1, grid2 : numpy.ndarray\n",
    "        Mesh grid coordinates for the observation plane\n",
    "    Ex, Ey, Ez : numpy.ndarray\n",
    "        Components of the electric field\n",
    "    E_mag : numpy.ndarray\n",
    "        Magnitude of the electric field\n",
    "    \"\"\"\n",
    "    # Determine the plate center position\n",
    "    plate_center = np.mean(charge_positions, axis=0)\n",
    "    \n",
    "    # Create mesh grid for the observation plane\n",
    "    if plate_orientation == 'xy':  # Plate in xy-plane, observation in xy-plane\n",
    "        # Observation plane is parallel to xy-plane at z = plate_center[2] + observation_distance\n",
    "        x = np.linspace(-plane_size[0]/2, plane_size[0]/2, num_points[0]) + plate_center[0]\n",
    "        y = np.linspace(-plane_size[1]/2, plane_size[1]/2, num_points[1]) + plate_center[1]\n",
    "        X, Y = np.meshgrid(x, y)\n",
    "        Z = np.full_like(X, plate_center[2] + observation_distance)\n",
    "        grid1, grid2 = X, Y  # First and second coordinates of the plane\n",
    "        \n",
    "    elif plate_orientation == 'yz':  # Plate in yz-plane, observation in yz-plane\n",
    "        # Observation plane is parallel to yz-plane at x = plate_center[0] + observation_distance\n",
    "        y = np.linspace(-plane_size[0]/2, plane_size[0]/2, num_points[0]) + plate_center[1]\n",
    "        z = np.linspace(-plane_size[1]/2, plane_size[1]/2, num_points[1]) + plate_center[2]\n",
    "        Y, Z = np.meshgrid(y, z)\n",
    "        X = np.full_like(Y, plate_center[0] + observation_distance)\n",
    "        grid1, grid2 = Y, Z  # First and second coordinates of the plane\n",
    "        \n",
    "    elif plate_orientation == 'xz':  # Plate in xz-plane, observation in xz-plane\n",
    "        # Observation plane is parallel to xz-plane at y = plate_center[1] + observation_distance\n",
    "        x = np.linspace(-plane_size[0]/2, plane_size[0]/2, num_points[0]) + plate_center[0]\n",
    "        z = np.linspace(-plane_size[1]/2, plane_size[1]/2, num_points[1]) + plate_center[2]\n",
    "        X, Z = np.meshgrid(x, z)\n",
    "        Y = np.full_like(X, plate_center[1] + observation_distance)\n",
    "        grid1, grid2 = X, Z  # First and second coordinates of the plane\n",
    "    \n",
    "    # Initialize field component arrays\n",
    "    Ex = np.zeros_like(grid1)\n",
    "    Ey = np.zeros_like(grid1)\n",
    "    Ez = np.zeros_like(grid1)\n",
    "    E_mag = np.zeros_like(grid1)\n",
    "    \n",
    "    # Calculate electric field at each point in the grid\n",
    "    for i in range(num_points[1]):\n",
    "        for j in range(num_points[0]):\n",
    "            field_point = [X[i, j], Y[i, j], Z[i, j]]\n",
    "                \n",
    "            E = electric_field_multiple_charges(charges, charge_positions, field_point)\n",
    "            \n",
    "            Ex[i, j] = E[0]\n",
    "            Ey[i, j] = E[1]\n",
    "            Ez[i, j] = E[2]\n",
    "            E_mag[i, j] = np.linalg.norm(E)\n",
    "    \n",
    "    return grid1, grid2, Ex, Ey, Ez, E_mag\n",
    "\n",
    "def plot_field_parallel_plane(grid1, grid2, Ex, Ey, Ez, E_mag, plate_orientation='xy', observation_distance=0.5):\n",
    "    \"\"\"\n",
    "    Plot the electric field on a plane parallel to the charged plate.\n",
    "    \n",
    "    Parameters:\n",
    "    -----------\n",
    "    grid1, grid2 : numpy.ndarray\n",
    "        Mesh grid coordinates for the observation plane\n",
    "    Ex, Ey, Ez : numpy.ndarray\n",
    "        Components of the electric field\n",
    "    E_mag : numpy.ndarray\n",
    "        Magnitude of the electric field\n",
    "    plate_orientation : str\n",
    "        Orientation of the plate ('xy', 'yz', or 'xz')\n",
    "    observation_distance : float\n",
    "        Distance from the plate to the observation plane\n",
    "    \"\"\"\n",
    "    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n",
    "    \n",
    "    # Get the components to plot based on orientation\n",
    "    if plate_orientation == 'xy':\n",
    "        # For xy-plane, show X and Y components, color by Z component\n",
    "        comp1, comp2 = Ex, Ey  # Vector components to plot (x, y)\n",
    "        perp_comp = Ez  # Perpendicular component (color)\n",
    "        ax1_label, ax2_label = 'X', 'Y'\n",
    "        perp_axis = 'Z'\n",
    "        \n",
    "    elif plate_orientation == 'yz':\n",
    "        # For yz-plane, show Y and Z components, color by X component\n",
    "        comp1, comp2 = Ey, Ez  # Vector components to plot (y, z)\n",
    "        perp_comp = Ex  # Perpendicular component (color)\n",
    "        ax1_label, ax2_label = 'Y', 'Z'\n",
    "        perp_axis = 'X'\n",
    "        \n",
    "    elif plate_orientation == 'xz':\n",
    "        # For xz-plane, show X and Z components, color by Y component\n",
    "        comp1, comp2 = Ex, Ez  # Vector components to plot (x, z)\n",
    "        perp_comp = Ey  # Perpendicular component (color)\n",
    "        ax1_label, ax2_label = 'X', 'Z'\n",
    "        perp_axis = 'Y'\n",
    "    \n",
    "    # Calculate an appropriate scale for the quiver plot based on field strength\n",
    "    max_comp = np.max(np.sqrt(comp1**2 + comp2**2))\n",
    "    scale_value = max_comp * 2  # Adjust this multiplier as needed for visual clarity\n",
    "    \n",
    "    # Plot 1: Vector field of in-plane components\n",
    "    ax1.set_title(f'Electric Field Vector Plot ({perp_axis}={observation_distance}m)')\n",
    "    ax1.set_xlabel(f'{ax1_label} (m)')\n",
    "    ax1.set_ylabel(f'{ax2_label} (m)')\n",
    "    \n",
    "    # Plot a subset of vectors for clarity\n",
    "    skip = slice(None, None, 2)\n",
    "    quiv = ax1.quiver(grid1[skip, skip], grid2[skip, skip], comp1[skip, skip], comp2[skip, skip], \n",
    "               angles='xy', scale_units='xy', scale=scale_value, width=0.003)\n",
    "    \n",
    "    # Add a key/legend for the quiver plot\n",
    "    key_value = round(max_comp / 2, -int(np.floor(np.log10(max_comp / 2))))  # Round to nice number\n",
    "    ax1.quiverkey(quiv, 0.9, 0.95, key_value, f'{key_value} N/C', labelpos='E')\n",
    "    \n",
    "    ax1.grid(True)\n",
    "    ax1.set_aspect('equal')\n",
    "    \n",
    "    # Plot 2: Perpendicular component as color map\n",
    "    # Use a symmetric colormap centered at zero for better visualization of positive/negative fields\n",
    "    max_val = np.max(np.abs(perp_comp))\n",
    "    norm = Normalize(vmin=-max_val, vmax=max_val)\n",
    "    \n",
    "    im = ax2.imshow(perp_comp, extent=[grid1.min(), grid1.max(), grid2.min(), grid2.max()], \n",
    "               origin='lower', cmap='RdBu_r', norm=norm, aspect='auto')\n",
    "    \n",
    "    ax2.set_title(f'{perp_axis}-Component of Electric Field ({perp_axis}={observation_distance}m)')\n",
    "    ax2.set_xlabel(f'{ax1_label} (m)')\n",
    "    ax2.set_ylabel(f'{ax2_label} (m)')\n",
    "    \n",
    "    # Add colorbar\n",
    "    cbar = plt.colorbar(im, ax=ax2)\n",
    "    cbar.set_label(f'{perp_axis}-Component (N/C)')\n",
    "    \n",
    "    ax2.grid(True)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    return fig\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Configuration\n",
    "    plate_width = 2.0  # meters\n",
    "    plate_height = 2.0  # meters\n",
    "    nx = 40  # number of charges along width\n",
    "    ny = 40  # number of charges along height\n",
    "    \n",
    "    # Set plate orientation - change this to 'xy', 'yz', or 'xz'\n",
    "    plate_orientation = 'yz'  # Plate in the yz-plane (x=0)\n",
    "    \n",
    "    # UNIFORM PATTERN - only keep this section uncommented\n",
    "    charge_pattern = 'uniform'\n",
    "    pattern_params = {'max_density': 1e-6}  # Uniform charge density\n",
    "    \n",
    "    charges, positions = generate_charged_plate_non_uniform(\n",
    "        plate_width, plate_height, nx, ny,\n",
    "        charge_pattern=charge_pattern,\n",
    "        pattern_params=pattern_params,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=[0, 0, 0]  # Plate centered at origin\n",
    "    )\n",
    "    \n",
    "    print(f\"Generated {len(charges)} charges for the plate\")\n",
    "    print(f\"Net charge: {np.sum(charges):.2e} C\")\n",
    "    print(f\"Charge range: {np.min(charges):.2e} to {np.max(charges):.2e} C\")\n",
    "    \n",
    "    # Visualize the charge distribution\n",
    "    visualize_charge_distribution(charges, positions, plate_orientation)\n",
    "    \n",
    "    # Set the observation distance from the plate\n",
    "    observation_distance = 0.5  # meters\n",
    "    \n",
    "    # Calculate the field on the parallel plane\n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag = calculate_field_parallel_plane(\n",
    "        charges, positions,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance,\n",
    "        plane_size=(2.5, 2.5),  # Size of the observation plane (slightly larger than plate)\n",
    "        num_points=(40, 40)  # Resolution (higher = more detail but slower)\n",
    "    )\n",
    "    \n",
    "    # Plot the results\n",
    "    fig = plot_field_parallel_plane(\n",
    "        grid1, grid2, Ex, Ey, Ez, E_mag,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance\n",
    "    )\n",
    "    \n",
    "    # ===== COMMENT OUT ALL SECTIONS BELOW THIS LINE IF YOU ONLY WANT UNIFORM DISTRIBUTION =====\n",
    "    \n",
    "    '''\n",
    "    # DIPOLE PATTERN - START OF COMMENT BLOCK\n",
    "    charge_pattern = 'dipole'\n",
    "    pattern_params = {\n",
    "        'axis': 'y',  # Dipole along y-axis\n",
    "        'max_density': 1e-6  # Maximum charge density (C/m²)\n",
    "    }\n",
    "    \n",
    "    charges, positions = generate_charged_plate_non_uniform(\n",
    "        plate_width, plate_height, nx, ny,\n",
    "        charge_pattern=charge_pattern,\n",
    "        pattern_params=pattern_params,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=[0, 0, 0]\n",
    "    )\n",
    "    \n",
    "    visualize_charge_distribution(charges, positions, plate_orientation)\n",
    "    \n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag = calculate_field_parallel_plane(\n",
    "        charges, positions,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance,\n",
    "        plane_size=(2.5, 2.5),\n",
    "        num_points=(40, 40)\n",
    "    )\n",
    "    \n",
    "    plot_field_parallel_plane(\n",
    "        grid1, grid2, Ex, Ey, Ez, E_mag,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance\n",
    "    )\n",
    "    # DIPOLE PATTERN - END OF COMMENT BLOCK\n",
    "    \n",
    "    # QUADRUPOLE PATTERN - START OF COMMENT BLOCK\n",
    "    charge_pattern = 'quadrupole'\n",
    "    pattern_params = {'max_density': 1e-6}\n",
    "    \n",
    "    charges, positions = generate_charged_plate_non_uniform(\n",
    "        plate_width, plate_height, nx, ny,\n",
    "        charge_pattern=charge_pattern,\n",
    "        pattern_params=pattern_params,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=[0, 0, 0]\n",
    "    )\n",
    "    \n",
    "    visualize_charge_distribution(charges, positions, plate_orientation)\n",
    "    \n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag = calculate_field_parallel_plane(\n",
    "        charges, positions,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance,\n",
    "        plane_size=(2.5, 2.5),\n",
    "        num_points=(40, 40)\n",
    "    )\n",
    "    \n",
    "    plot_field_parallel_plane(\n",
    "        grid1, grid2, Ex, Ey, Ez, E_mag,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance\n",
    "    )\n",
    "    # QUADRUPOLE PATTERN - END OF COMMENT BLOCK\n",
    "\n",
    "    # GAUSSIAN PATTERN - START OF COMMENT BLOCK\n",
    "    charge_pattern = 'gaussian'\n",
    "    pattern_params = {'sigma': 0.4, 'amplitude': 1e-6}\n",
    "    \n",
    "    charges, positions = generate_charged_plate_non_uniform(\n",
    "        plate_width, plate_height, nx, ny,\n",
    "        charge_pattern=charge_pattern,\n",
    "        pattern_params=pattern_params,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=[0, 0, 0]\n",
    "    )\n",
    "    \n",
    "    visualize_charge_distribution(charges, positions, plate_orientation)\n",
    "    \n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag = calculate_field_parallel_plane(\n",
    "        charges, positions,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance,\n",
    "        plane_size=(2.5, 2.5),\n",
    "        num_points=(40, 40)\n",
    "    )\n",
    "    \n",
    "    plot_field_parallel_plane(\n",
    "        grid1, grid2, Ex, Ey, Ez, E_mag,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance\n",
    "    )\n",
    "    # GAUSSIAN PATTERN - END OF COMMENT BLOCK\n",
    "    \n",
    "    # CUSTOM PATTERN - START OF COMMENT BLOCK\n",
    "    def custom_charge_function(x, y):\n",
    "        r1 = np.sqrt((x - 0.5)**2 + y**2)\n",
    "        r2 = np.sqrt((x + 0.5)**2 + y**2)\n",
    "        q1 = 1e-6 * np.exp(-r1**2 / 0.1)  # Positive charge at (0.5, 0)\n",
    "        q2 = -1e-6 * np.exp(-r2**2 / 0.1)  # Negative charge at (-0.5, 0)\n",
    "        return q1 + q2\n",
    "    \n",
    "    charge_pattern = 'custom'\n",
    "    pattern_params = {'function': custom_charge_function}\n",
    "    \n",
    "    charges, positions = generate_charged_plate_non_uniform(\n",
    "        plate_width, plate_height, nx, ny,\n",
    "        charge_pattern=charge_pattern,\n",
    "        pattern_params=pattern_params,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=[0, 0, 0]\n",
    "    )\n",
    "    \n",
    "    visualize_charge_distribution(charges, positions, plate_orientation)\n",
    "    \n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag = calculate_field_parallel_plane(\n",
    "        charges, positions,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance,\n",
    "        plane_size=(2.5, 2.5),\n",
    "        num_points=(40, 40)\n",
    "    )\n",
    "    \n",
    "    plot_field_parallel_plane(\n",
    "        grid1, grid2, Ex, Ey, Ez, E_mag,\n",
    "        plate_orientation=plate_orientation,\n",
    "        observation_distance=observation_distance\n",
    "    )\n",
    "    # CUSTOM PATTERN - END OF COMMENT BLOCK\n",
    "    '''"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2151628e-e12f-41a1-b634-230d442eb799",
   "metadata": {},
   "source": [
    "# Capacitor Field Cross Section\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b2ddbfcd-0e89-4b5b-b27b-5b9468df0a65",
   "metadata": {
    "jupyter": {
     "source_hidden": true
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.colors import Normalize\n",
    "from matplotlib import cm\n",
    "\n",
    "# Constants\n",
    "k = 8.9875e9  # Coulomb's constant (N·m²/C²)\n",
    "\n",
    "def electric_field(charge, charge_position, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the electric field at a point due to a single point charge.\n",
    "    \"\"\"\n",
    "    # Convert inputs to numpy arrays\n",
    "    charge_position = np.array(charge_position)\n",
    "    field_point = np.array(field_point)\n",
    "    \n",
    "    # Calculate displacement vector from charge to field point\n",
    "    r_vector = field_point - charge_position\n",
    "    \n",
    "    # Calculate distance\n",
    "    r = np.linalg.norm(r_vector)\n",
    "    \n",
    "    # Check for singularity (field point at charge position)\n",
    "    if r < 1e-10:\n",
    "        return np.zeros(3)\n",
    "    \n",
    "    # Calculate unit vector\n",
    "    r_hat = r_vector / r\n",
    "    \n",
    "    # Calculate electric field magnitude\n",
    "    E_magnitude = k * charge / (r**2)\n",
    "    \n",
    "    # Calculate electric field vector\n",
    "    E_field = E_magnitude * r_hat\n",
    "    \n",
    "    return E_field\n",
    "\n",
    "def electric_field_multiple_charges(charges, charge_positions, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the total electric field at a point due to multiple charges.\n",
    "    \"\"\"\n",
    "    # Initialize total field\n",
    "    total_E_field = np.zeros(3)\n",
    "    \n",
    "    # Sum the contributions from each charge\n",
    "    for i, (charge, position) in enumerate(zip(charges, charge_positions)):\n",
    "        E_field = electric_field(charge, position, field_point)\n",
    "        total_E_field += E_field\n",
    "        \n",
    "    return total_E_field\n",
    "\n",
    "def generate_charged_plate(width, height, nx, ny, \n",
    "                          plate_orientation='xy', center_position=[0, 0, 0],\n",
    "                          charge_density=1e-6):\n",
    "    \"\"\"\n",
    "    Generate a uniformly charged rectangular plate.\n",
    "    \"\"\"\n",
    "    # Calculate the area represented by each point charge\n",
    "    dx = width / nx\n",
    "    dy = height / ny\n",
    "    area_per_charge = dx * dy\n",
    "    \n",
    "    # Calculate charge per point based on uniform density\n",
    "    charge_value = charge_density * area_per_charge\n",
    "    \n",
    "    charges = []\n",
    "    positions = []\n",
    "    \n",
    "    center_position = np.array(center_position)\n",
    "    \n",
    "    # Create a grid of charges based on orientation\n",
    "    for i in range(nx):\n",
    "        for j in range(ny):\n",
    "            # Calculate position relative to center\n",
    "            rel_x = (i + 0.5) * dx - width/2\n",
    "            rel_y = (j + 0.5) * dy - height/2\n",
    "            \n",
    "            # Set position based on plate orientation\n",
    "            if plate_orientation == 'xy':  # Plate in xy-plane\n",
    "                x = rel_x + center_position[0]\n",
    "                y = rel_y + center_position[1]\n",
    "                z = center_position[2]\n",
    "                \n",
    "            elif plate_orientation == 'yz':  # Plate in yz-plane\n",
    "                y = rel_x + center_position[1]  # rel_x maps to y-axis\n",
    "                z = rel_y + center_position[2]  # rel_y maps to z-axis\n",
    "                x = center_position[0]\n",
    "                \n",
    "            elif plate_orientation == 'xz':  # Plate in xz-plane\n",
    "                x = rel_x + center_position[0]  # rel_x maps to x-axis\n",
    "                z = rel_y + center_position[2]  # rel_y maps to z-axis\n",
    "                y = center_position[1]\n",
    "                \n",
    "            charges.append(charge_value)\n",
    "            positions.append([x, y, z])\n",
    "    \n",
    "    return np.array(charges), np.array(positions)\n",
    "\n",
    "def generate_parallel_plates(width, height, nx, ny, plate_separation, \n",
    "                            plate_orientation='xy', center_position=[0, 0, 0],\n",
    "                            charge_density=1e-6):\n",
    "    \"\"\"\n",
    "    Generate two parallel uniformly charged plates with opposite charges.\n",
    "    \"\"\"\n",
    "    center_position = np.array(center_position)\n",
    "    \n",
    "    # Calculate the centers of the two plates\n",
    "    if plate_orientation == 'xy':\n",
    "        # Plates in xy-plane, separation along z-axis\n",
    "        plate1_center = center_position + np.array([0, 0, plate_separation/2])\n",
    "        plate2_center = center_position + np.array([0, 0, -plate_separation/2])\n",
    "        normal_axis = 'z'\n",
    "    \n",
    "    elif plate_orientation == 'yz':\n",
    "        # Plates in yz-plane, separation along x-axis\n",
    "        plate1_center = center_position + np.array([plate_separation/2, 0, 0])\n",
    "        plate2_center = center_position + np.array([-plate_separation/2, 0, 0])\n",
    "        normal_axis = 'x'\n",
    "    \n",
    "    elif plate_orientation == 'xz':\n",
    "        # Plates in xz-plane, separation along y-axis\n",
    "        plate1_center = center_position + np.array([0, plate_separation/2, 0])\n",
    "        plate2_center = center_position + np.array([0, -plate_separation/2, 0])\n",
    "        normal_axis = 'y'\n",
    "    \n",
    "    # Generate the first plate (positive charge)\n",
    "    charges1, positions1 = generate_charged_plate(\n",
    "        width, height, nx, ny,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=plate1_center,\n",
    "        charge_density=charge_density\n",
    "    )\n",
    "    \n",
    "    # Generate the second plate (negative charge)\n",
    "    charges2, positions2 = generate_charged_plate(\n",
    "        width, height, nx, ny,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=plate2_center,\n",
    "        charge_density=-charge_density  # Negative charge\n",
    "    )\n",
    "    \n",
    "    # Combine charges and positions from both plates\n",
    "    all_charges = np.concatenate((charges1, charges2))\n",
    "    all_positions = np.concatenate((positions1, positions2))\n",
    "    \n",
    "    return all_charges, all_positions, plate1_center, plate2_center, normal_axis\n",
    "\n",
    "def calculate_field_cross_section(charges, charge_positions, \n",
    "                                slice_plane='xz', slice_position=0.0,\n",
    "                                slice_size=(3.0, 3.0), num_points=(60, 60)):\n",
    "    \"\"\"\n",
    "    Calculate the electric field on a cross-section slice.\n",
    "    \"\"\"\n",
    "    # Create mesh grid for the slice\n",
    "    if slice_plane == 'xy':  # Slice in xy-plane at z=slice_position\n",
    "        x = np.linspace(-slice_size[0]/2, slice_size[0]/2, num_points[0])\n",
    "        y = np.linspace(-slice_size[1]/2, slice_size[1]/2, num_points[1])\n",
    "        X, Y = np.meshgrid(x, y)\n",
    "        Z = np.full_like(X, slice_position)\n",
    "        grid1, grid2 = X, Y\n",
    "        perpendicular_axis = 'z'\n",
    "        \n",
    "    elif slice_plane == 'yz':  # Slice in yz-plane at x=slice_position\n",
    "        y = np.linspace(-slice_size[0]/2, slice_size[0]/2, num_points[0])\n",
    "        z = np.linspace(-slice_size[1]/2, slice_size[1]/2, num_points[1])\n",
    "        Y, Z = np.meshgrid(y, z)\n",
    "        X = np.full_like(Y, slice_position)\n",
    "        grid1, grid2 = Y, Z\n",
    "        perpendicular_axis = 'x'\n",
    "        \n",
    "    elif slice_plane == 'xz':  # Slice in xz-plane at y=slice_position\n",
    "        x = np.linspace(-slice_size[0]/2, slice_size[0]/2, num_points[0])\n",
    "        z = np.linspace(-slice_size[1]/2, slice_size[1]/2, num_points[1])\n",
    "        X, Z = np.meshgrid(x, z)\n",
    "        Y = np.full_like(X, slice_position)\n",
    "        grid1, grid2 = X, Z\n",
    "        perpendicular_axis = 'y'\n",
    "    \n",
    "    # Initialize field component arrays\n",
    "    Ex = np.zeros_like(grid1)\n",
    "    Ey = np.zeros_like(grid1)\n",
    "    Ez = np.zeros_like(grid1)\n",
    "    E_mag = np.zeros_like(grid1)\n",
    "    \n",
    "    # Calculate electric field at each point in the grid\n",
    "    for i in range(num_points[1]):\n",
    "        for j in range(num_points[0]):\n",
    "            if slice_plane == 'xy':\n",
    "                field_point = [X[i, j], Y[i, j], Z[i, j]]\n",
    "            elif slice_plane == 'yz':\n",
    "                field_point = [X[i, j], Y[i, j], Z[i, j]]\n",
    "            elif slice_plane == 'xz':\n",
    "                field_point = [X[i, j], Y[i, j], Z[i, j]]\n",
    "                \n",
    "            E = electric_field_multiple_charges(charges, charge_positions, field_point)\n",
    "            \n",
    "            Ex[i, j] = E[0]\n",
    "            Ey[i, j] = E[1]\n",
    "            Ez[i, j] = E[2]\n",
    "            E_mag[i, j] = np.linalg.norm(E)\n",
    "    \n",
    "    return grid1, grid2, Ex, Ey, Ez, E_mag, perpendicular_axis\n",
    "\n",
    "def visualize_cross_section_vectors(charges, positions, plate1_center, plate2_center, normal_axis,\n",
    "                                   plate_width, plate_height, plate_orientation, slice_plane):\n",
    "    \"\"\"\n",
    "    Visualize a single cross-section through the middle of the plates,\n",
    "    representing the plates as infinitesimally thin lines and the electric field as unit vectors.\n",
    "    \"\"\"\n",
    "    # Determine the slice position (middle of the capacitor)\n",
    "    slice_position = 0.0  # Center position\n",
    "    \n",
    "    # Calculate fields on the cross-section\n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag, perp_axis = calculate_field_cross_section(\n",
    "        charges, positions,\n",
    "        slice_plane=slice_plane,\n",
    "        slice_position=slice_position,\n",
    "        slice_size=(plate_width * 2.5, plate_height * 2.5),  # Make the view area larger than plates\n",
    "        num_points=(20, 20)  # Lower resolution for clearer vectors\n",
    "    )\n",
    "    \n",
    "    # Create a figure with a single axes\n",
    "    fig, ax = plt.subplots(figsize=(12, 10))\n",
    "    \n",
    "    # Get the components to plot based on orientation\n",
    "    if slice_plane == 'xy':\n",
    "        comp1, comp2 = Ex, Ey  # Vector components to plot\n",
    "        ax1_label, ax2_label = 'X', 'Y'\n",
    "        axis1_idx, axis2_idx = 0, 1  # Indices for extracting plate coordinates\n",
    "        \n",
    "    elif slice_plane == 'yz':\n",
    "        comp1, comp2 = Ey, Ez  # Vector components to plot\n",
    "        ax1_label, ax2_label = 'Y', 'Z'\n",
    "        axis1_idx, axis2_idx = 1, 2\n",
    "        \n",
    "    elif slice_plane == 'xz':\n",
    "        comp1, comp2 = Ex, Ez  # Vector components to plot\n",
    "        ax1_label, ax2_label = 'X', 'Z'\n",
    "        axis1_idx, axis2_idx = 0, 2\n",
    "    \n",
    "    \n",
    "    # Calculate unit vectors for the quiver plot\n",
    "    unit_comp1 = np.zeros_like(comp1)\n",
    "    unit_comp2 = np.zeros_like(comp2)\n",
    "    \n",
    "    # Avoid division by zero\n",
    "    mag = np.sqrt(comp1**2 + comp2**2)\n",
    "    mask = mag > 1e-10\n",
    "    \n",
    "    unit_comp1[mask] = comp1[mask] / mag[mask]\n",
    "    unit_comp2[mask] = comp2[mask] / mag[mask]\n",
    "    \n",
    "    # Create a quiver plot with unit vectors\n",
    "    skip = 1  # Adjust to change vector density\n",
    "    quiv = ax.quiver(grid1[::skip, ::skip], grid2[::skip, ::skip], \n",
    "                   unit_comp1[::skip, ::skip], unit_comp2[::skip, ::skip],\n",
    "                   E_mag[::skip, ::skip],  # Color by magnitude\n",
    "                   cmap='viridis',\n",
    "                   scale=25,  # Adjust for vector size\n",
    "                   width=0.004,  # Width of arrow\n",
    "                   headwidth=3,  # Head width\n",
    "                   pivot='mid')  # Arrow pivots at midpoint\n",
    "    \n",
    "    # Add colorbar for the field magnitude\n",
    "    cbar = plt.colorbar(quiv, ax=ax)\n",
    "    cbar.set_label('Electric Field Magnitude (N/C)')\n",
    "    \n",
    "    # Draw the plates as lines\n",
    "    if plate_orientation == 'xy' and slice_plane == 'xz':\n",
    "        # For xy plates viewed in xz slice, draw the edges of the plates as lines\n",
    "        plate1_z = plate1_center[2]\n",
    "        plate2_z = plate2_center[2]\n",
    "        x_min = -plate_width/2\n",
    "        x_max = plate_width/2\n",
    "        \n",
    "        # Top plate edge (positive)\n",
    "        ax.plot([x_min, x_max], [plate1_z, plate1_z], 'r-', linewidth=3, label='Positive Plate (+)')\n",
    "        # Add + symbols along the plate\n",
    "        num_symbols = 10\n",
    "        for i in range(num_symbols):\n",
    "            x_pos = x_min + (x_max - x_min) * (i + 0.5) / num_symbols\n",
    "            ax.text(x_pos, plate1_z, '+', color='red', fontsize=14, \n",
    "                   ha='center', va='center', fontweight='bold')\n",
    "        \n",
    "        # Bottom plate edge (negative)\n",
    "        ax.plot([x_min, x_max], [plate2_z, plate2_z], 'b-', linewidth=3, label='Negative Plate (-)')\n",
    "        # Add - symbols along the plate\n",
    "        for i in range(num_symbols):\n",
    "            x_pos = x_min + (x_max - x_min) * (i + 0.5) / num_symbols\n",
    "            ax.text(x_pos, plate2_z, '−', color='blue', fontsize=14, \n",
    "                   ha='center', va='center', fontweight='bold')\n",
    "    \n",
    "    elif plate_orientation == 'xy' and slice_plane == 'yz':\n",
    "        # For xy plates viewed in yz slice, draw the edges of the plates as lines\n",
    "        plate1_z = plate1_center[2]\n",
    "        plate2_z = plate2_center[2]\n",
    "        y_min = -plate_height/2\n",
    "        y_max = plate_height/2\n",
    "        \n",
    "        # Top plate edge (positive)\n",
    "        ax.plot([y_min, y_max], [plate1_z, plate1_z], 'r-', linewidth=3, label='Positive Plate (+)')\n",
    "        # Add + symbols along the plate\n",
    "        num_symbols = 5\n",
    "        for i in range(num_symbols):\n",
    "            y_pos = y_min + (y_max - y_min) * (i + 0.5) / num_symbols\n",
    "            ax.text(y_pos, plate1_z, '+', color='red', fontsize=14, \n",
    "                   ha='center', va='center', fontweight='bold')\n",
    "        \n",
    "        # Bottom plate edge (negative)\n",
    "        ax.plot([y_min, y_max], [plate2_z, plate2_z], 'b-', linewidth=3, label='Negative Plate (-)')\n",
    "        # Add - symbols along the plate\n",
    "        for i in range(num_symbols):\n",
    "            y_pos = y_min + (y_max - y_min) * (i + 0.5) / num_symbols\n",
    "            ax.text(y_pos, plate2_z, '−', color='blue', fontsize=14, \n",
    "                   ha='center', va='center', fontweight='bold')\n",
    "    \n",
    "    # Add gridlines\n",
    "    ax.grid(True, linestyle='--', alpha=0.7)\n",
    "    \n",
    "    # Set labels and title\n",
    "    ax.set_xlabel(f'{ax1_label} (m)')\n",
    "    ax.set_ylabel(f'{ax2_label} (m)')\n",
    "    ax.set_title(f'Electric Field Cross-Section Through Capacitor: {slice_plane.upper()}-Plane (Unit Vectors)')\n",
    "    \n",
    "    # Set aspect ratio\n",
    "    ax.set_aspect('equal')\n",
    "    \n",
    "    # Add legend\n",
    "    ax.legend(loc='upper right')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    \n",
    "    return fig\n",
    "\n",
    "def main():\n",
    "    \"\"\"\n",
    "    Main function to run the capacitor simulation and visualization.\n",
    "    \"\"\"\n",
    "    # Configuration\n",
    "    plate_width = 1.0  # meters\n",
    "    plate_height = 1.0  # meters\n",
    "    plate_separation = 0.5  # meters\n",
    "    \n",
    "    # Number of charges to represent each plate\n",
    "    nx = 20  # points along width\n",
    "    ny = 20  # points along height\n",
    "    \n",
    "    # Charge density (C/m²)\n",
    "    charge_density = 1e-6\n",
    "    \n",
    "    # Orientation of the capacitor plates\n",
    "    # Options: 'xy', 'yz', or 'xz'\n",
    "    plate_orientation = 'xy'\n",
    "    \n",
    "    # Generate the capacitor plates\n",
    "    charges, positions, plate1_center, plate2_center, normal_axis = generate_parallel_plates(\n",
    "        plate_width, plate_height, nx, ny, \n",
    "        plate_separation=plate_separation,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=[0, 0, 0],\n",
    "        charge_density=charge_density\n",
    "    )\n",
    "    \n",
    "    print(f\"Generated capacitor with {len(charges)} charges\")\n",
    "    print(f\"Plate orientation: {plate_orientation}-plane\")\n",
    "    print(f\"Plate separation: {plate_separation} m\")\n",
    "    print(f\"Plate 1 center (positive): {plate1_center}\")\n",
    "    print(f\"Plate 2 center (negative): {plate2_center}\")\n",
    "    \n",
    "    # For xy-oriented plates, choose xz plane to see the cross-section\n",
    "    if plate_orientation == 'xy':\n",
    "        slice_plane = 'xz'  # slice along x-z plane to see the field between plates\n",
    "    elif plate_orientation == 'yz':\n",
    "        slice_plane = 'xz'  # slice along x-z plane\n",
    "    elif plate_orientation == 'xz':\n",
    "        slice_plane = 'xy'  # slice along x-y plane\n",
    "        \n",
    "    # Visualize the cross-section with unit vectors\n",
    "    fig = visualize_cross_section_vectors(\n",
    "        charges, positions, \n",
    "        plate1_center, plate2_center, \n",
    "        normal_axis,\n",
    "        plate_width, plate_height, \n",
    "        plate_orientation, \n",
    "        slice_plane\n",
    "    )\n",
    "    \n",
    "    plt.show()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "32fb919a-1beb-4007-9433-39a5e15d03fe",
   "metadata": {},
   "source": [
    "# Capacitor w/ Dielectric "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "f38c60c2-8005-47fb-b4bc-ddd2966cee85",
   "metadata": {
    "jupyter": {
     "source_hidden": true
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Generated capacitor with 1600 charges\n",
      "Plate orientation: xy-plane\n",
      "Plate separation: 0.5 m\n",
      "Plate 1 center (positive): [0.   0.   0.25]\n",
      "Plate 2 center (negative): [ 0.    0.   -0.25]\n",
      "Dielectric center: [0.   0.   0.05]\n",
      "Dielectric thickness: 0.1 m\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'plate_separation' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[2], line 536\u001b[0m\n\u001b[1;32m    533\u001b[0m     plt\u001b[38;5;241m.\u001b[39mshow()\n\u001b[1;32m    535\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;18m__name__\u001b[39m \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m__main__\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[0;32m--> 536\u001b[0m     main()\n",
      "Cell \u001b[0;32mIn[2], line 521\u001b[0m, in \u001b[0;36mmain\u001b[0;34m()\u001b[0m\n\u001b[1;32m    518\u001b[0m     slice_plane \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mxy\u001b[39m\u001b[38;5;124m'\u001b[39m  \u001b[38;5;66;03m# slice along x-y plane\u001b[39;00m\n\u001b[1;32m    520\u001b[0m \u001b[38;5;66;03m# Visualize the cross-section with unit vectors\u001b[39;00m\n\u001b[0;32m--> 521\u001b[0m fig \u001b[38;5;241m=\u001b[39m visualize_cross_section_vectors(\n\u001b[1;32m    522\u001b[0m     charges, positions, \n\u001b[1;32m    523\u001b[0m     plate1_center, plate2_center, \n\u001b[1;32m    524\u001b[0m     dielectric_center, actual_thickness, \n\u001b[1;32m    525\u001b[0m     normal_axis,\n\u001b[1;32m    526\u001b[0m     plate_width, plate_height, \n\u001b[1;32m    527\u001b[0m     plate_orientation, \n\u001b[1;32m    528\u001b[0m     slice_plane,\n\u001b[1;32m    529\u001b[0m     pos_positions, neg_positions\n\u001b[1;32m    530\u001b[0m )\n\u001b[1;32m    532\u001b[0m plt\u001b[38;5;241m.\u001b[39msavefig(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mcapacitor_with_dielectric_focused.png\u001b[39m\u001b[38;5;124m'\u001b[39m, dpi\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m300\u001b[39m)\n\u001b[1;32m    533\u001b[0m plt\u001b[38;5;241m.\u001b[39mshow()\n",
      "Cell \u001b[0;32mIn[2], line 290\u001b[0m, in \u001b[0;36mvisualize_cross_section_vectors\u001b[0;34m(charges, positions, plate1_center, plate2_center, dielectric_center, dielectric_thickness, normal_axis, plate_width, plate_height, plate_orientation, slice_plane, pos_surface_positions, neg_surface_positions)\u001b[0m\n\u001b[1;32m    288\u001b[0m \u001b[38;5;66;03m# Calculate fields on the cross-section - focus more narrowly on the capacitor region\u001b[39;00m\n\u001b[1;32m    289\u001b[0m view_size_x \u001b[38;5;241m=\u001b[39m plate_width \u001b[38;5;241m*\u001b[39m \u001b[38;5;241m1.2\u001b[39m  \u001b[38;5;66;03m# Only slightly wider than the plates\u001b[39;00m\n\u001b[0;32m--> 290\u001b[0m view_size_z \u001b[38;5;241m=\u001b[39m plate_separation \u001b[38;5;241m*\u001b[39m \u001b[38;5;241m1.5\u001b[39m  \u001b[38;5;66;03m# Only slightly taller than the separation\u001b[39;00m\n\u001b[1;32m    292\u001b[0m grid1, grid2, Ex, Ey, Ez, E_mag, perp_axis \u001b[38;5;241m=\u001b[39m calculate_field_cross_section(\n\u001b[1;32m    293\u001b[0m     charges, positions,\n\u001b[1;32m    294\u001b[0m     slice_plane\u001b[38;5;241m=\u001b[39mslice_plane,\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m    297\u001b[0m     num_points\u001b[38;5;241m=\u001b[39m(\u001b[38;5;241m40\u001b[39m, \u001b[38;5;241m40\u001b[39m)  \u001b[38;5;66;03m# Higher resolution for better field visualization\u001b[39;00m\n\u001b[1;32m    298\u001b[0m )\n\u001b[1;32m    300\u001b[0m \u001b[38;5;66;03m# Create a figure with a single axes\u001b[39;00m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'plate_separation' is not defined"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.colors import Normalize\n",
    "from matplotlib import cm\n",
    "\n",
    "# Constants\n",
    "k = 8.9875e9  # Coulomb's constant (N·m²/C²)\n",
    "\n",
    "def electric_field(charge, charge_position, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the electric field at a point due to a single point charge.\n",
    "    \"\"\"\n",
    "    # Convert inputs to numpy arrays\n",
    "    charge_position = np.array(charge_position)\n",
    "    field_point = np.array(field_point)\n",
    "    \n",
    "    # Calculate displacement vector from charge to field point\n",
    "    r_vector = field_point - charge_position\n",
    "    \n",
    "    # Calculate distance\n",
    "    r = np.linalg.norm(r_vector)\n",
    "    \n",
    "    # Check for singularity (field point at charge position)\n",
    "    if r < 1e-10:\n",
    "        return np.zeros(3)\n",
    "    \n",
    "    # Calculate unit vector\n",
    "    r_hat = r_vector / r\n",
    "    \n",
    "    # Calculate electric field magnitude\n",
    "    E_magnitude = k * charge / (r**2)\n",
    "    \n",
    "    # Calculate electric field vector\n",
    "    E_field = E_magnitude * r_hat\n",
    "    \n",
    "    return E_field\n",
    "\n",
    "def electric_field_multiple_charges(charges, charge_positions, field_point):\n",
    "    \"\"\"\n",
    "    Calculate the total electric field at a point due to multiple charges.\n",
    "    \"\"\"\n",
    "    # Initialize total field\n",
    "    total_E_field = np.zeros(3)\n",
    "    \n",
    "    # Sum the contributions from each charge\n",
    "    for i, (charge, position) in enumerate(zip(charges, charge_positions)):\n",
    "        E_field = electric_field(charge, position, field_point)\n",
    "        total_E_field += E_field\n",
    "        \n",
    "    return total_E_field\n",
    "\n",
    "def generate_charged_plate(width, height, nx, ny, \n",
    "                          plate_orientation='xy', center_position=[0, 0, 0],\n",
    "                          charge_density=1e-6):\n",
    "    \"\"\"\n",
    "    Generate a uniformly charged rectangular plate.\n",
    "    \"\"\"\n",
    "    # Calculate the area represented by each point charge\n",
    "    dx = width / nx\n",
    "    dy = height / ny\n",
    "    area_per_charge = dx * dy\n",
    "    \n",
    "    # Calculate charge per point based on uniform density\n",
    "    charge_value = charge_density * area_per_charge\n",
    "    \n",
    "    charges = []\n",
    "    positions = []\n",
    "    \n",
    "    center_position = np.array(center_position)\n",
    "    \n",
    "    # Create a grid of charges based on orientation\n",
    "    for i in range(nx):\n",
    "        for j in range(ny):\n",
    "            # Calculate position relative to center\n",
    "            rel_x = (i + 0.5) * dx - width/2\n",
    "            rel_y = (j + 0.5) * dy - height/2\n",
    "            \n",
    "            # Set position based on plate orientation\n",
    "            if plate_orientation == 'xy':  # Plate in xy-plane\n",
    "                x = rel_x + center_position[0]\n",
    "                y = rel_y + center_position[1]\n",
    "                z = center_position[2]\n",
    "                \n",
    "            elif plate_orientation == 'yz':  # Plate in yz-plane\n",
    "                y = rel_x + center_position[1]  # rel_x maps to y-axis\n",
    "                z = rel_y + center_position[2]  # rel_y maps to z-axis\n",
    "                x = center_position[0]\n",
    "                \n",
    "            elif plate_orientation == 'xz':  # Plate in xz-plane\n",
    "                x = rel_x + center_position[0]  # rel_x maps to x-axis\n",
    "                z = rel_y + center_position[2]  # rel_y maps to z-axis\n",
    "                y = center_position[1]\n",
    "                \n",
    "            charges.append(charge_value)\n",
    "            positions.append([x, y, z])\n",
    "    \n",
    "    return np.array(charges), np.array(positions)\n",
    "\n",
    "def generate_parallel_plates(width, height, nx, ny, plate_separation, \n",
    "                            plate_orientation='xy', center_position=[0, 0, 0],\n",
    "                            charge_density=1e-6):\n",
    "    \"\"\"\n",
    "    Generate two parallel uniformly charged plates with opposite charges.\n",
    "    \"\"\"\n",
    "    center_position = np.array(center_position)\n",
    "    \n",
    "    # Calculate the centers of the two plates\n",
    "    if plate_orientation == 'xy':\n",
    "        # Plates in xy-plane, separation along z-axis\n",
    "        plate1_center = center_position + np.array([0, 0, plate_separation/2])\n",
    "        plate2_center = center_position + np.array([0, 0, -plate_separation/2])\n",
    "        normal_axis = 'z'\n",
    "    \n",
    "    elif plate_orientation == 'yz':\n",
    "        # Plates in yz-plane, separation along x-axis\n",
    "        plate1_center = center_position + np.array([plate_separation/2, 0, 0])\n",
    "        plate2_center = center_position + np.array([-plate_separation/2, 0, 0])\n",
    "        normal_axis = 'x'\n",
    "    \n",
    "    elif plate_orientation == 'xz':\n",
    "        # Plates in xz-plane, separation along y-axis\n",
    "        plate1_center = center_position + np.array([0, plate_separation/2, 0])\n",
    "        plate2_center = center_position + np.array([0, -plate_separation/2, 0])\n",
    "        normal_axis = 'y'\n",
    "    \n",
    "    # Generate the first plate (positive charge)\n",
    "    charges1, positions1 = generate_charged_plate(\n",
    "        width, height, nx, ny,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=plate1_center,\n",
    "        charge_density=charge_density\n",
    "    )\n",
    "    \n",
    "    # Generate the second plate (negative charge)\n",
    "    charges2, positions2 = generate_charged_plate(\n",
    "        width, height, nx, ny,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=plate2_center,\n",
    "        charge_density=-charge_density  # Negative charge\n",
    "    )\n",
    "    \n",
    "    # Combine charges and positions from both plates\n",
    "    all_charges = np.concatenate((charges1, charges2))\n",
    "    all_positions = np.concatenate((positions1, positions2))\n",
    "    \n",
    "    return all_charges, all_positions, plate1_center, plate2_center, normal_axis\n",
    "\n",
    "def generate_dielectric_plate(width, height, nx, ny, \n",
    "                          plate_orientation='xy', center_position=[0, 0, 0],\n",
    "                          surface_charge_density=1e-7, thickness=0.05):\n",
    "    \"\"\"\n",
    "    Generate a dielectric plate with surface charges due to polarization.\n",
    "    Similar to generate_charged_plate but creates two surfaces with opposite charges.\n",
    "    \"\"\"\n",
    "    # Calculate the area represented by each point charge\n",
    "    dx = width / nx\n",
    "    dy = height / ny\n",
    "    area_per_charge = dx * dy\n",
    "    \n",
    "    # Calculate charge per point based on surface charge density\n",
    "    charge_value = surface_charge_density * area_per_charge\n",
    "    \n",
    "    # We'll create two sets of charges - one for each surface of the dielectric\n",
    "    charges_positive = []\n",
    "    charges_negative = []\n",
    "    positions_positive = []\n",
    "    positions_negative = []\n",
    "    \n",
    "    # Separation between charge layers is the thickness of the dielectric\n",
    "    surface_separation = thickness\n",
    "    \n",
    "    center_position = np.array(center_position)\n",
    "    \n",
    "    # Create a grid of charges based on orientation\n",
    "    for i in range(nx):\n",
    "        for j in range(ny):\n",
    "            # Calculate position relative to center\n",
    "            rel_x = (i + 0.5) * dx - width/2\n",
    "            rel_y = (j + 0.5) * dy - height/2\n",
    "            \n",
    "            # Set positions based on plate orientation\n",
    "            if plate_orientation == 'xy':  # Plate in xy-plane\n",
    "                x = rel_x + center_position[0]\n",
    "                y = rel_y + center_position[1]\n",
    "                z_pos = center_position[2] + surface_separation/2\n",
    "                z_neg = center_position[2] - surface_separation/2\n",
    "                \n",
    "                pos_positive = [x, y, z_pos]\n",
    "                pos_negative = [x, y, z_neg]\n",
    "                \n",
    "            elif plate_orientation == 'yz':  # Plate in yz-plane\n",
    "                y = rel_x + center_position[1]\n",
    "                z = rel_y + center_position[2]\n",
    "                x_pos = center_position[0] + surface_separation/2\n",
    "                x_neg = center_position[0] - surface_separation/2\n",
    "                \n",
    "                pos_positive = [x_pos, y, z]\n",
    "                pos_negative = [x_neg, y, z]\n",
    "                \n",
    "            elif plate_orientation == 'xz':  # Plate in xz-plane\n",
    "                x = rel_x + center_position[0]\n",
    "                z = rel_y + center_position[2]\n",
    "                y_pos = center_position[1] + surface_separation/2\n",
    "                y_neg = center_position[1] - surface_separation/2\n",
    "                \n",
    "                pos_positive = [x, y_pos, z]\n",
    "                pos_negative = [x, y_neg, z]\n",
    "            \n",
    "            # Add charges and positions\n",
    "            charges_positive.append(charge_value)\n",
    "            charges_negative.append(-charge_value)\n",
    "            positions_positive.append(pos_positive)\n",
    "            positions_negative.append(pos_negative)\n",
    "    \n",
    "    # Combine all charges and positions\n",
    "    all_charges = np.concatenate((charges_positive, charges_negative))\n",
    "    all_positions = np.array(positions_positive + positions_negative)\n",
    "    \n",
    "    return all_charges, all_positions, surface_separation, positions_positive, positions_negative\n",
    "\n",
    "def calculate_field_cross_section(charges, charge_positions, \n",
    "                                slice_plane='xz', slice_position=0.0,\n",
    "                                slice_size=(3.0, 3.0), num_points=(60, 60)):\n",
    "    \"\"\"\n",
    "    Calculate the electric field on a cross-section slice.\n",
    "    \"\"\"\n",
    "    # Create mesh grid for the slice\n",
    "    if slice_plane == 'xy':  # Slice in xy-plane at z=slice_position\n",
    "        x = np.linspace(-slice_size[0]/2, slice_size[0]/2, num_points[0])\n",
    "        y = np.linspace(-slice_size[1]/2, slice_size[1]/2, num_points[1])\n",
    "        X, Y = np.meshgrid(x, y)\n",
    "        Z = np.full_like(X, slice_position)\n",
    "        grid1, grid2 = X, Y\n",
    "        perpendicular_axis = 'z'\n",
    "        \n",
    "    elif slice_plane == 'yz':  # Slice in yz-plane at x=slice_position\n",
    "        y = np.linspace(-slice_size[0]/2, slice_size[0]/2, num_points[0])\n",
    "        z = np.linspace(-slice_size[1]/2, slice_size[1]/2, num_points[1])\n",
    "        Y, Z = np.meshgrid(y, z)\n",
    "        X = np.full_like(Y, slice_position)\n",
    "        grid1, grid2 = Y, Z\n",
    "        perpendicular_axis = 'x'\n",
    "        \n",
    "    elif slice_plane == 'xz':  # Slice in xz-plane at y=slice_position\n",
    "        x = np.linspace(-slice_size[0]/2, slice_size[0]/2, num_points[0])\n",
    "        z = np.linspace(-slice_size[1]/2, slice_size[1]/2, num_points[1])\n",
    "        X, Z = np.meshgrid(x, z)\n",
    "        Y = np.full_like(X, slice_position)\n",
    "        grid1, grid2 = X, Z\n",
    "        perpendicular_axis = 'y'\n",
    "    \n",
    "    # Initialize field component arrays\n",
    "    Ex = np.zeros_like(grid1)\n",
    "    Ey = np.zeros_like(grid1)\n",
    "    Ez = np.zeros_like(grid1)\n",
    "    E_mag = np.zeros_like(grid1)\n",
    "    \n",
    "    # Calculate electric field at each point in the grid\n",
    "    for i in range(num_points[1]):\n",
    "        for j in range(num_points[0]):\n",
    "            if slice_plane == 'xy':\n",
    "                field_point = [X[i, j], Y[i, j], Z[i, j]]\n",
    "            elif slice_plane == 'yz':\n",
    "                field_point = [X[i, j], Y[i, j], Z[i, j]]\n",
    "            elif slice_plane == 'xz':\n",
    "                field_point = [X[i, j], Y[i, j], Z[i, j]]\n",
    "                \n",
    "            E = electric_field_multiple_charges(charges, charge_positions, field_point)\n",
    "            \n",
    "            Ex[i, j] = E[0]\n",
    "            Ey[i, j] = E[1]\n",
    "            Ez[i, j] = E[2]\n",
    "            E_mag[i, j] = np.linalg.norm(E)\n",
    "    \n",
    "    return grid1, grid2, Ex, Ey, Ez, E_mag, perpendicular_axis\n",
    "\n",
    "def visualize_cross_section_vectors(charges, positions, plate1_center, plate2_center, \n",
    "                                   dielectric_center, dielectric_thickness, normal_axis,\n",
    "                                   plate_width, plate_height, plate_orientation, slice_plane,\n",
    "                                   pos_surface_positions, neg_surface_positions):\n",
    "    \"\"\"\n",
    "    Visualize a single cross-section through the middle of the plates,\n",
    "    representing the plates as infinitesimally thin lines and the electric field as unit vectors.\n",
    "    \"\"\"\n",
    "    # Determine the slice position (middle of the capacitor)\n",
    "    slice_position = 0.0  # Center position\n",
    "    \n",
    "    # Calculate fields on the cross-section - focus more narrowly on the capacitor region\n",
    "    view_size_x = plate_width * 1.2  # Only slightly wider than the plates\n",
    "    view_size_z = plate_separation * 1.5  # Only slightly taller than the separation\n",
    "    \n",
    "    grid1, grid2, Ex, Ey, Ez, E_mag, perp_axis = calculate_field_cross_section(\n",
    "        charges, positions,\n",
    "        slice_plane=slice_plane,\n",
    "        slice_position=slice_position,\n",
    "        slice_size=(view_size_x, view_size_z),  # Focused view\n",
    "        num_points=(40, 40)  # Higher resolution for better field visualization\n",
    "    )\n",
    "    \n",
    "    # Create a figure with a single axes\n",
    "    fig, ax = plt.subplots(figsize=(12, 10))\n",
    "    \n",
    "    # Get the components to plot based on orientation\n",
    "    if slice_plane == 'xy':\n",
    "        comp1, comp2 = Ex, Ey  # Vector components to plot\n",
    "        ax1_label, ax2_label = 'X', 'Y'\n",
    "        axis1_idx, axis2_idx = 0, 1  # Indices for extracting plate coordinates\n",
    "        \n",
    "    elif slice_plane == 'yz':\n",
    "        comp1, comp2 = Ey, Ez  # Vector components to plot\n",
    "        ax1_label, ax2_label = 'Y', 'Z'\n",
    "        axis1_idx, axis2_idx = 1, 2\n",
    "        \n",
    "    elif slice_plane == 'xz':\n",
    "        comp1, comp2 = Ex, Ez  # Vector components to plot\n",
    "        ax1_label, ax2_label = 'X', 'Z'\n",
    "        axis1_idx, axis2_idx = 0, 2\n",
    "    \n",
    "    # Calculate unit vectors for the quiver plot\n",
    "    unit_comp1 = np.zeros_like(comp1)\n",
    "    unit_comp2 = np.zeros_like(comp2)\n",
    "    \n",
    "    # Avoid division by zero\n",
    "    mag = np.sqrt(comp1**2 + comp2**2)\n",
    "    mask = mag > 1e-10\n",
    "    \n",
    "    unit_comp1[mask] = comp1[mask] / mag[mask]\n",
    "    unit_comp2[mask] = comp2[mask] / mag[mask]\n",
    "    \n",
    "    # Create a quiver plot with unit vectors\n",
    "    skip = 1  # Adjust to change vector density\n",
    "    quiv = ax.quiver(grid1[::skip, ::skip], grid2[::skip, ::skip], \n",
    "                   unit_comp1[::skip, ::skip], unit_comp2[::skip, ::skip],\n",
    "                   E_mag[::skip, ::skip],  # Color by magnitude\n",
    "                   cmap='viridis',\n",
    "                   scale=20,  # Adjusted for vector size\n",
    "                   width=0.004,  # Width of arrow\n",
    "                   headwidth=3,  # Head width\n",
    "                   pivot='mid')  # Arrow pivots at midpoint\n",
    "    \n",
    "    # Add colorbar for the field magnitude\n",
    "    cbar = plt.colorbar(quiv, ax=ax)\n",
    "    cbar.set_label('Electric Field Magnitude (N/C)')\n",
    "    \n",
    "    # Draw the plates as lines\n",
    "    if plate_orientation == 'xy' and slice_plane == 'xz':\n",
    "        # For xy plates viewed in xz slice, draw the edges of the plates as lines\n",
    "        plate1_z = plate1_center[2]\n",
    "        plate2_z = plate2_center[2]\n",
    "        x_min = -plate_width/2\n",
    "        x_max = plate_width/2\n",
    "        \n",
    "        # Top plate edge (positive)\n",
    "        ax.plot([x_min, x_max], [plate1_z, plate1_z], 'r-', linewidth=3, label='Positive Plate (+)')\n",
    "        # Add + symbols along the plate\n",
    "        num_symbols = 10\n",
    "        for i in range(num_symbols):\n",
    "            x_pos = x_min + (x_max - x_min) * (i + 0.5) / num_symbols\n",
    "            ax.text(x_pos, plate1_z, '+', color='red', fontsize=14, \n",
    "                   ha='center', va='center', fontweight='bold')\n",
    "        \n",
    "        # Bottom plate edge (negative)\n",
    "        ax.plot([x_min, x_max], [plate2_z, plate2_z], 'b-', linewidth=3, label='Negative Plate (-)')\n",
    "        # Add - symbols along the plate\n",
    "        for i in range(num_symbols):\n",
    "            x_pos = x_min + (x_max - x_min) * (i + 0.5) / num_symbols\n",
    "            ax.text(x_pos, plate2_z, '−', color='blue', fontsize=14, \n",
    "                   ha='center', va='center', fontweight='bold')\n",
    "        \n",
    "        # Draw the dielectric as a thick colored line with different colors for surfaces\n",
    "        dielectric_z = dielectric_center[2]\n",
    "        dielectric_top = dielectric_z + dielectric_thickness/2\n",
    "        dielectric_bottom = dielectric_z - dielectric_thickness/2\n",
    "        \n",
    "        # Fill the dielectric region\n",
    "        ax.fill_between([x_min, x_max], dielectric_bottom, dielectric_top, \n",
    "                       color='green', alpha=0.3, label='Dielectric')\n",
    "        \n",
    "        # Extract only the Z coordinates from positions to get surface positions at this slice\n",
    "        if len(pos_surface_positions) > 0 and len(neg_surface_positions) > 0:\n",
    "            pos_z = [pos[2] for pos in pos_surface_positions]\n",
    "            neg_z = [pos[2] for pos in neg_surface_positions]\n",
    "        \n",
    "            # Draw the top edge of the dielectric (positive surface charge)\n",
    "            ax.plot([x_min, x_max], [dielectric_top, dielectric_top], 'r-', linewidth=2, alpha=0.8)\n",
    "            \n",
    "            # Draw the bottom edge of the dielectric (negative surface charge)\n",
    "            ax.plot([x_min, x_max], [dielectric_bottom, dielectric_bottom], 'b-', linewidth=2, alpha=0.8)\n",
    "        \n",
    "            # Label the dielectric with polarization charges\n",
    "            num_diel_symbols = 10\n",
    "            for i in range(num_diel_symbols):\n",
    "                x_pos = x_min + (x_max - x_min) * (i + 0.5) / num_diel_symbols\n",
    "                # Add δ+ and δ- symbols to show polarization\n",
    "                ax.text(x_pos, dielectric_top, 'δ+', color='darkred', fontsize=12, \n",
    "                       ha='center', va='center', fontweight='bold')\n",
    "                ax.text(x_pos, dielectric_bottom, 'δ-', color='darkblue', fontsize=12, \n",
    "                       ha='center', va='center', fontweight='bold')\n",
    "    \n",
    "    # Add gridlines\n",
    "    ax.grid(True, linestyle='--', alpha=0.7)\n",
    "    \n",
    "    # Set labels and title\n",
    "    ax.set_xlabel(f'{ax1_label} (m)')\n",
    "    ax.set_ylabel(f'{ax2_label} (m)')\n",
    "    ax.set_title(f'Electric Field in Capacitor with Dielectric: {slice_plane.upper()}-Plane View')\n",
    "    \n",
    "    # Set aspect ratio\n",
    "    ax.set_aspect('equal')\n",
    "    \n",
    "    # Add legend\n",
    "    ax.legend(loc='upper right')\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    \n",
    "    return fig\n",
    "\n",
    "def generate_capacitor_with_dielectric(width, height, nx, ny, plate_separation, \n",
    "                                     dielectric_position=0.0,  # 0.0 means centered\n",
    "                                     dielectric_thickness=0.05,  # thickness of dielectric\n",
    "                                     plate_orientation='xy', \n",
    "                                     center_position=[0, 0, 0],\n",
    "                                     plate_charge_density=1e-6,\n",
    "                                     dielectric_surface_charge_density=1e-7):\n",
    "    \"\"\"\n",
    "    Generate a capacitor with a dielectric slab inside.\n",
    "    \"\"\"\n",
    "    # Generate the capacitor plates first\n",
    "    plate_charges, plate_positions, plate1_center, plate2_center, normal_axis = generate_parallel_plates(\n",
    "        width, height, nx, ny,\n",
    "        plate_separation=plate_separation,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=center_position,\n",
    "        charge_density=plate_charge_density\n",
    "    )\n",
    "    \n",
    "    # Calculate dielectric position based on the relative position parameter\n",
    "    # dielectric_position = 0 means centered, 1 means at positive plate, -1 means at negative plate\n",
    "    if plate_orientation == 'xy':\n",
    "        dielectric_z = center_position[2] + (plate_separation/2) * dielectric_position\n",
    "        dielectric_center = np.array([center_position[0], center_position[1], dielectric_z])\n",
    "    elif plate_orientation == 'yz':\n",
    "        dielectric_x = center_position[0] + (plate_separation/2) * dielectric_position\n",
    "        dielectric_center = np.array([dielectric_x, center_position[1], center_position[2]])\n",
    "    elif plate_orientation == 'xz':\n",
    "        dielectric_y = center_position[1] + (plate_separation/2) * dielectric_position\n",
    "        dielectric_center = np.array([center_position[0], dielectric_y, center_position[2]])\n",
    "    \n",
    "    # Generate the dielectric\n",
    "    dielectric_charges, dielectric_positions, actual_thickness, pos_positions, neg_positions = generate_dielectric_plate(\n",
    "        width, height, nx, ny,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=dielectric_center,\n",
    "        surface_charge_density=dielectric_surface_charge_density,\n",
    "        thickness=dielectric_thickness\n",
    "    )\n",
    "    \n",
    "    # Combine all charges and positions\n",
    "    all_charges = np.concatenate((plate_charges, dielectric_charges))\n",
    "    all_positions = np.concatenate((plate_positions, dielectric_positions))\n",
    "    \n",
    "    return (all_charges, all_positions, plate1_center, plate2_center, \n",
    "            dielectric_center, actual_thickness, normal_axis, pos_positions, neg_positions)\n",
    "\n",
    "def main():\n",
    "    \"\"\"\n",
    "    Main function to run the capacitor simulation with dielectric.\n",
    "    \"\"\"\n",
    "    # Configuration\n",
    "    plate_width = 1.0  # meters\n",
    "    plate_height = 1.0  # meters\n",
    "    plate_separation = 0.5  # meters\n",
    "    \n",
    "    # Number of charges to represent each plate\n",
    "    nx = 20  # points along width\n",
    "    ny = 20  # points along height\n",
    "    \n",
    "    # Charge densities\n",
    "    plate_charge_density = 1e-6  # C/m² for plates\n",
    "    dielectric_surface_charge_density = 8e-7  # C/m² for dielectric surfaces - increased for better visibility\n",
    "    \n",
    "    # Dielectric thickness\n",
    "    dielectric_thickness = 0.1  # meters\n",
    "    \n",
    "    # Dielectric position (0 = centered, 1 = at positive plate, -1 = at negative plate)\n",
    "    dielectric_position = 0.2  # slightly offset from center toward positive plate for better visualization\n",
    "    \n",
    "    # Orientation of the capacitor plates\n",
    "    plate_orientation = 'xy'\n",
    "    \n",
    "    # Generate the capacitor with dielectric\n",
    "    (charges, positions, plate1_center, plate2_center, dielectric_center, \n",
    "     actual_thickness, normal_axis, pos_positions, neg_positions) = generate_capacitor_with_dielectric(\n",
    "        plate_width, plate_height, nx, ny, \n",
    "        plate_separation=plate_separation,\n",
    "        dielectric_position=dielectric_position,\n",
    "        dielectric_thickness=dielectric_thickness,\n",
    "        plate_orientation=plate_orientation,\n",
    "        center_position=[0, 0, 0],\n",
    "        plate_charge_density=plate_charge_density,\n",
    "        dielectric_surface_charge_density=dielectric_surface_charge_density\n",
    "    )\n",
    "    \n",
    "    print(f\"Generated capacitor with {len(charges)} charges\")\n",
    "    print(f\"Plate orientation: {plate_orientation}-plane\")\n",
    "    print(f\"Plate separation: {plate_separation} m\")\n",
    "    print(f\"Plate 1 center (positive): {plate1_center}\")\n",
    "    print(f\"Plate 2 center (negative): {plate2_center}\")\n",
    "    print(f\"Dielectric center: {dielectric_center}\")\n",
    "    print(f\"Dielectric thickness: {actual_thickness} m\")\n",
    "    \n",
    "    # For xy-oriented plates, choose xz plane to see the cross-section\n",
    "    if plate_orientation == 'xy':\n",
    "        slice_plane = 'xz'  # slice along x-z plane to see the field between plates\n",
    "    elif plate_orientation == 'yz':\n",
    "        slice_plane = 'xz'  # slice along x-z plane\n",
    "    elif plate_orientation == 'xz':\n",
    "        slice_plane = 'xy'  # slice along x-y plane\n",
    "        \n",
    "    # Visualize the cross-section with unit vectors\n",
    "    fig = visualize_cross_section_vectors(\n",
    "        charges, positions, \n",
    "        plate1_center, plate2_center, \n",
    "        dielectric_center, actual_thickness, \n",
    "        normal_axis,\n",
    "        plate_width, plate_height, \n",
    "        plate_orientation, \n",
    "        slice_plane,\n",
    "        pos_positions, neg_positions\n",
    "    )\n",
    "    \n",
    "    plt.savefig('capacitor_with_dielectric_focused.png', dpi=300)\n",
    "    plt.show()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "25d4286a-071a-4f67-9087-00326a2f9b02",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
